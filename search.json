[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced single cell analysis",
    "section": "",
    "text": "Welcome! This homepage contains specialized tutorials to perform single cell analysis. The main languages proposed here are python and R, and rarely bash for specific command-line tools. The page will be populated both with examples of complete downstream analysis and guides for specific tasks, such as gene networks, cell-cell communication, clustering techniques, integration and comparison, data visualization.\nAll available tutorials are found in the toolbar menu Material."
  },
  {
    "objectID": "index.html#running-the-notebooks",
    "href": "index.html#running-the-notebooks",
    "title": "Advanced single cell analysis",
    "section": "Running the notebooks",
    "text": "Running the notebooks\nAll tutorials can be seen in this webpage as compiled jupyter notebooks for inspiration and self-learning. To execute the notebooks you have various options:\n\nAccess to the uCloud interactive computing system (for danish universities/institutional users), where we have developed the Transcriptomics Sandbox app. This has a wide choice of modules for self-learning in transcriptomics (bulkRNA and single cell RNA analysis).\nAccess to GenomeDK (danish bioinformatics cluster, for which you need to have an account) and execution of a Docker container through singularity.\nDocker container, executable on any system running the Docker engine (we suggest using your own/local computing cluster or a performant computer, since most tutorials will need a large amount of RAM memory and CPU power). You can also run the Docker container through the Singularity software.\nPackage setup on a Conda environment, where you create a conda environment and perform the package installations to run the tutorials (note that some packages are not present in conda, and you need to install them manually by opening R).\n\nThe instructions are found in the toolbar menu Access."
  },
  {
    "objectID": "index.html#available-tutorials",
    "href": "index.html#available-tutorials",
    "title": "Advanced single cell analysis",
    "section": "Available tutorials",
    "text": "Available tutorials\n\nIntegrated Analysis of Single-Cell Transcriptomics Datasets Across Conditions\nIntegrated analysis of single-cell transcriptomics datasets from the plant species Lotus Japonicus. The datasets are control and rhizobia-infected root samples. This data offers a comprehensive example for data integration and analysis of\n\nkey regulatory networks\nsignaling pathways\ncell-type-specific responses to infections\n\nThe comparative analysis includes clustering, conserved and divergent transcriptional signatures, gene networks, use of GO terms, differential expression.\nThe presented tutorial does not only enhance the understanding of implications of specific conditions, but also provides valuable insights for comparative analysis in the health field. By extrapolating methodologies and findings, researchers can apply similar integrative approaches to analyze single-cell transcriptomics datasets from human or animal studies under different disease conditions.\nThis cross-disciplinary approach facilitates the identification of shared regulatory networks and disease-specific signatures, advancing our knowledge of host-pathogen interactions and aiding in the development of targeted therapeutic interventions for infectious diseases.\n\nData availability\n\nData repository Code repository\n\n\n\n\nAcknowledgements\nIf you publish a paper or present a project where you have used our material:\n\ncite the data (with the Zenodo DOI and also the eventual publication presenting the data)\ncite the tutorials repository (with the Zenodo DOI ???)\nacknowledge the Novo Nordisk Foundation grant Danish halth data science sandbox, Grant Number NNF20OC0063268"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html",
    "title": "Single Cell Analysis Tutorial",
    "section": "",
    "text": "This tutorial will give you the extensive basic commands and explanations for the single cell analysis of your own dataset.\nThe first two parts follow the phylosophy of the best practices explained in Luecken and Theis (2019) and Heumos et al. (2023). The third part applies standard statistical tests on the average gene expressions in subsets of the data. The last part is based pulling cells transcripts together with different granularities to improve the statistical power of calculations based on their gene expression (as in Morabito et al. (2023)).\nThe tutorial is based on four samples of Lotus Japonicus (two rhizobia-infected and two wild types) from Frank et al. (2023). The last section follows some of the tutorials from hdWGCNA."
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#a-rather-very-short-biological-background",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#a-rather-very-short-biological-background",
    "title": "Single Cell Analysis Tutorial",
    "section": "0.1 A (rather very) short biological background",
    "text": "0.1 A (rather very) short biological background\nLotus Japonicus is a legume characterized by the legume-rhizobium symbiotic interaction (rhizobia are soil microorganisms that can interact with leguminous plants to form root nodules within which conditions are favourable for bacterial nitrogen fixation. Legumes allow the development of very large rhizobial populations in the vicinity of their roots). Figure 1 and text below it from Wang, Liu, and Zhu (2018).\n\n\n\nFigure 1: Symbiosis signaling and plant immunity involved in recognition specificity in the legume-rhizobial interactions (indicated by the red stars). A The process of infection and nodule development. A mature indeterminate nodule contains a meristem zone (I), an infection zone (II), an interzone (IZ), a nitrogen fixing zone (III), and a senescent zone (IV). B The host secretes flavonoids to induce the expression of bacterial nodulation (nod) gene through the activation of NodD proteins. The enzymes encoded by the nod genes lead to the synthesis of Nod factors (NF) that are recognized by host Nod factor receptors (NFRs). Recognition specificity occurs both between Flavonoids and NodDs and between NF and NFRs. C In addition to NF signaling, bacteria also produce extracellular polysaccharides (EPS) and type III effectors to facilitate their infection in compatible interactions, but these molecules may also induce immune responses causing resistance to infection in incompatible interactions. D Certain legumes such as Medicago encode antimicrobial nodule-specific cysteine-rich (NCR) peptides to drive their bacterial partners to terminal differentiation that is required for nitrogen fixation. However, some rhizobial strains cannot survive the antibacterial activity of certain peptide isoforms, leading to formation of nodules defective in nitrogen fixation.\n\n\nRhizobial invasion of legumes is primarily mediated by a plant-made tubular invagination called an infection thread (IT). Research has shown that various genes are involved in some of the processes of the legume-rhizobia interaction. Figure 2 and text below it from Szczyglowski et al. (1998).\n\n\n\nFigure 2: Primary infection of Lotus japonicus roots inoculated with Mesorhizobium loti strain NZP2235. A, Brightfield micrograph of root hair curlings resembling shepherd’s-crook structures (arrows). B–C, Phase contrast micrographs of the intracellular infection threads within curled root hairs. Arrows point to infection threads with papilla-like structures on their outer surface. Bar, 70 µm A, 25 µm B, and 20 µm C.\n\n\n\nRINRK1 (Rhizobial Infection Receptor-like Kinase1), that is induced by Nod factors (NFs) and is involved in IT formation but not nodule organogenesis. A paralog, RINRK2, plays a relatively minor role in infection. RINRK1 is required for full induction of early infection genes, including Nodule Inception (NIN), encoding an essential nodulation transcription factor. See Li et al. (2019).\nHAR1 mediates nitrate inhibition and autoregulation of nodulation. Autoregulation of nodulation involves root-to-shoot-to-root long-distance communication, and HAR1 functions in shoots. HAR1 is critical for the inhibition of nodulation at 10 mM nitrate. The nitrate-induced CLE-RS2 glycopeptide binds directly to the HAR1 receptor, this result suggests that CLE-RS2/HAR1 long-distance signaling plays an important role in the both nitrate inhibition and the autoregulation of nodulation. See Okamoto and Kawaguchi (2015).\nSYMRKL1, encodes a protein with an ectodomain predicted to be nearly identical to that of SYMRK and is required for normal infection thread formation. See Frank et al. (2023)."
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#the-raw-data-in-practice",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#the-raw-data-in-practice",
    "title": "Single Cell Analysis Tutorial",
    "section": "1.1 The raw data in practice",
    "text": "1.1 The raw data in practice\nLet’s look at a specific read and its UMI and cell barcode. The data is organized in paired-end reads (written on fastq files), where the first fastq file contains reads in the following format\n@SRR8363305.1 1 length=26\nNTGAAGTGTTAAGACAAGCGTGAACT\n+SRR8363305.1 1 length=26\n#AAFFJJJJJJJJJJJJJJJJFJJJJ\nHere, the first 16 characters NTGAAGTGTTAAGACA represent the cell barcode, while the last 10 characters AGCGTGAACT are the transcript UMI tag. The last line represents the quality scores of the 26 characters of barcode+UMI.\nThe associated second fastq file contains reads of 98nt as the following\n@SRR8363305.1 1 length=98\nNCTAAAGATCACACTAAGGCAACTCATGGAGGGGTCTTCAAAGA\n    CCTTGCAAGAAGTACTAACTATGGAGTATCGGCTAAGTCAANCN\n    TGTATGAGAT\n+SRR8363305.1 1 length=98\n#A&lt;77AFJJFAAAJJJ7-7-&lt;7FJ-7----&lt;77--7FAAA--\n    &lt;JFFF-7--7&lt;&lt;-F77---FF---7-7A-777777A-&lt;\n    -7---#-#A-7-7--7--\nThe 98nt-long string of characters in the second line is a partial sequence of the cDNA transcript. Specifically, the 10X chromium protocol used for sequencing the data is biased towards the 3’ end, because the sequencing is oriented from the 3’ to the 5’ end of the transcripts. The last line contains the corresponding quality scores."
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#alignment-and-expression-matrix",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#alignment-and-expression-matrix",
    "title": "Single Cell Analysis Tutorial",
    "section": "1.2 Alignment and expression matrix",
    "text": "1.2 Alignment and expression matrix\nThe data is aligned with cellranger, a completely automatized pipeline implemented by 10X for 10X-genomics data.\nApart from the data, the output contains an interactive document reporting the quality of the data and a small preliminary UMAP plot and clustering. In this report it is especially instructive to look at the knee plot.\nThe knee plot is created by plotting the number of unique molecular identifiers (UMIs) or reads against the number of cells sequenced, sorted in descending order. The UMIs or reads are a measure of the amount of RNA captured for each cell, and thus a measure of the quality of the data. The plot typically shows a steep slope at the beginning, followed by a plateau, and then a gradual decrese into a second slope and a final plateau.\n\nThe steep slope represents the initial cells that are of high quality and have the highest number of UMIs or reads.\nThe first plateau represents the cells that have lower quality data, and the gradual decrease represents the addition of droplets with even lower quality data.\nUsually, beyond the first slope, you have droplets that are either empty or of so poor quality, that they are not worth keeping for analysis.\nThe height of the last plateau gives you an idea of the presence of ambient RNA inside droplets. If the last plateau is located high up, then the corresponding amount of UMIs consist of background ambient RNA which likely pollutes all cells in your data.\n\nBelow, the knee plot from the control 1 sample used in this analysis. You can see that around 10,000 cells with above ~1000 UMIs seems to be coinsidered of decent quality by cellranger (the part of line coloured in blue). Note that the last plateau is located at a very low amount of UMIs, meaning there is not really any relevant contamination from ambient RNA.\n\n\n\nFigure 5: Knee plot of the Control 1 sample of the tutorial. Note the lower plateau of ambient RNA\n\n\n\n\n\n\n\n\nExercise\n\n\n\nIn this same folder you have the document web_summary.html that shows you the quality report of an example dataset produced using the 10X cellranger pipeline for alignment. Take some time to look at it and explore what it contains (Click on Trust HTML on the top menu if the html remains blank after opening it). Get an idea of how many UMIs there are in cells of decent quality. We will work more on filtering out cells based on their quality in this tutorial.\nYou can read a technical note on interpreting cellranger reports.\n\n\n\n\n\n\n\n\nSomething more about knee plots\n\n\n\n\n\nThe background RNA (sequenced together with the transcript coming from the cell of interest) makes up the ambient plateau: the same background RNA is contained in empty droplets. If your dataset has extremely few UMI counts in empty droplets, then there is not much background RNA present - This is the best situation in which you can find yourself. See Exhibit A in Figure 6.\nIf you have a dataset where you can identify an empty droplet plateau by eye (Exhibit B in Figure 6), and these empty droplets have 50 or 100 or several hundred counts, then it can be advisable to use a specific software to remove the background transcripts (e.g. CellBender (Fleming et al. (2023)), SoupX (Young and Behjati (2020))).\nIf you have a dataset with so much background RNA that you cannot identify the empty droplet plateau yourself by eye (Exhibit C in Figure 6), then any software to remove background transcripts will also likely have a difficult time. Such the algorithms might be worth a try, but you should strongly consider re-running the experiment, as the knee plot points to a real QC failure\n\n\n\nFigure 6: Various cases of knee plot you can encounter from sequenced data. Figure from the webpage of Cellbender."
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#download-data",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#download-data",
    "title": "Single Cell Analysis Tutorial",
    "section": "2.1 Download data",
    "text": "2.1 Download data\nWe check if the data exists, otherwise a script will download the missing data files in the appropriate folder, which should be ../Data.\n\ndownloadData()\n\nData folder exists. Check for files and eventually downloads them. Please wait.\n\nDone!"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#import-data",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#import-data",
    "title": "Single Cell Analysis Tutorial",
    "section": "2.2 Import data",
    "text": "2.2 Import data\nWe import the data reading the matrix files aligned by 10X. Those are usually contained in a folder with a name of the type aligned_dataset/outs/filtered_bc_matrix, that 10X Cellranger creates automatically after the alignment. You need to use such a folder when your own data is aligned and you need to import it. In this tutorial, the aligned data is in the folder ../Data/control_1 used below. The command for reading the data is simply Read10X.\n\nControl1 &lt;- Read10X(\"../Data/control_1/\")\n\n\n\n\n\n\n\nPreprocessing multiple datasets\n\n\n\nNote that we are loading only one dataset (control_1, one of the two control replicates). Another control dataset, and two infected datasets, have already been preprocessed and will be used later - so we will now focus on the preprocessing of a single dataset. In general, when you have multiple datasets, you must preprocess them one at a time before integrating them together.\n\n\nWhat we obtain in the command above is an expression matrix. Look at the first 10 rows and columns of the matrix (whose rows represent genes and columns droplets/cells) - the dots are zeros (they are not stored in the data, which has a compressed format called dgCMatrix), and are the majority of the expression values obtained in scRNA data!\n\nControl1[1:10,1:10]\n\n  [[ suppressing 10 column names ‘AAACCCAAGGGCAGTT-1’, ‘AAACCCAAGTCAGCGA-1’, ‘AAACCCACACTAACCA-1’ ... ]]\n\n\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n                                         \nLotjaGi0g1v0000100    . . . . . . . . . .\nLotjaGi0g1v0000200    . . . . . . . . . .\nLotjaGi0g1v0000300    . . . . . . . . . .\nLotjaGi0g1v0000400    . . . . . . 1 1 . .\nLotjaGi0g1v0000500    . . . . . . . . . .\nLotjaGi0g1v0000600    . . . . . . . . . .\nLotjaGi0g1v0000700    . . . . . . . . . .\nLotjaGi0g1v0000800    . . . . 1 . . . . .\nLotjaGi0g1v0000900_LC . . . . . . . . . .\nLotjaGi0g1v0001000_LC . . . . . . . . . .\n\n\nWhat is the percentage of zeros in this matrix? You can see it for yourself below - it is a lot, but quite surprisingly we can get a lot of information from the data!\n\ncat(\"Number of zeros: \")\nzeros &lt;-  sum(Control1==0)\ncat( zeros )\n\nNumber of zeros: 307060673\n\n\n\ncat(\"Number of expression entries: \")\ntotal &lt;- dim(Control1)[1] * dim(Control1)[2]\ncat( total )\n\nNumber of expression entries: 329798055\n\n\n\ncat(\"Percentage of zeros: \")\ncat( zeros / total * 100 )\n\nPercentage of zeros: 93.10567"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#create-a-single-cell-object-in-seurat",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#create-a-single-cell-object-in-seurat",
    "title": "Single Cell Analysis Tutorial",
    "section": "2.3 Create a single cell object in Seurat",
    "text": "2.3 Create a single cell object in Seurat\nWe use our count matrix to create a Seurat object. A Seurat object allows you to store the count matrix and future modifications of it (for example its normalized version), together with information regarding cells and genes (such as clusters of cell types) and their projections (such as PCA and tSNE). We will go through these elements, but first we create the object with CreateSeuratObject:\n\nControl1_seurat &lt;- CreateSeuratObject(counts = Control1, \n                                               project = \"Control1_seurat\", \n                                               min.cells = 3, \n                                               min.features = 200)\n\nWarning message:\n“Feature names cannot have underscores ('_'), replacing with dashes ('-')”\nWarning message:\n“Feature names cannot have underscores ('_'), replacing with dashes ('-')”\n\n\nThe arguments of the command are * counts: the count matrix * project: a project name * min.cells: a minimum requirement for genes, in our case saying they must be expressed in at least 3 cells. If not, they are filtered out already now when creating the object. * min.features: a minimum requirement for cells. Cells having less than 200 expressed genes are removed from the beginning from the data.\nValues for the minimum requirements chosen above are standard checks when running the analysis. Droplets not satisfying those requirements are of extremely bad quality and not worth carrying on during the analysis (remember the knee plot).\nHow many genes and cells have been filtered out?\n\ncat(\"Starting Genes and Cells:\\n\")\ncat( dim(Control1) )\n\ncat(\"\\nFiltered Genes and Cells:\\n\")\ncat( dim(Control1) - dim(Control1_seurat) )\n\ncat(\"\\nRemaining Genes and Cells:\\n\")\ncat( dim(Control1_seurat) )\n\nStarting Genes and Cells:\n30585 10783\nFiltered Genes and Cells:\n6747 11\nRemaining Genes and Cells:\n23838 10772\n\n\nWe want to use this data later in the analysis with other Control and Infected datasets. Therefore we add a Condition to the metadata table, and for this dataset we establish that each cell is Control.\n\nControl1_seurat &lt;- AddMetaData(object = Control1_seurat, \n                                        metadata = \"Control\", \n                                        col.name = \"Condition\")\n\n\n2.3.1 Content of a Seurat Object\nWhat is contained in the Seurat object? We can use the command str to list the various slots of the object.\n\nstr(Control1_seurat, max.level = 2)\n\nFormal class 'Seurat' [package \"SeuratObject\"] with 13 slots\n  ..@ assays      :List of 1\n  ..@ meta.data   :'data.frame':    10772 obs. of  4 variables:\n  ..@ active.assay: chr \"RNA\"\n  ..@ active.ident: Factor w/ 1 level \"Control1_seurat\": 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..- attr(*, \"names\")= chr [1:10772] \"AAACCCAAGGGCAGTT-1\" \"AAACCCAAGTCAGCGA-1\" \"AAACCCACACTAACCA-1\" \"AAACCCACATGATCTG-1\" ...\n  ..@ graphs      : list()\n  ..@ neighbors   : list()\n  ..@ reductions  : list()\n  ..@ images      : list()\n  ..@ project.name: chr \"Control1_seurat\"\n  ..@ misc        : list()\n  ..@ version     :Classes 'package_version', 'numeric_version'  hidden list of 1\n  ..@ commands    : list()\n  ..@ tools       : list()\n\n\nThe first slot is called assays, and it contains all the count matrices we have collected during our analysis when, for example, normalizing data or doing other transformations of it. Right now we only have the RNA assay with the raw counts:\n\nControl1_seurat@assays\n\n$RNA\nAssay data with 23838 features for 10772 cells\nFirst 10 features:\n LotjaGi0g1v0000100, LotjaGi0g1v0000200, LotjaGi0g1v0000300,\nLotjaGi0g1v0000400, LotjaGi0g1v0000500, LotjaGi0g1v0000700,\nLotjaGi0g1v0000800, LotjaGi0g1v0001100, LotjaGi0g1v0001200,\nLotjaGi0g1v0001400 \n\n\nYou can always select which matrix is currently in use for the analysis by assigning it to DefaultAssay(). The default assay is often changed automatically by Seurat, for example the normalized assay is used as default after normalization is performed.\n\nDefaultAssay(object = Control1_seurat) &lt;- \"RNA\"\n\n\ncat(\"Your default assay is \")\ncat(DefaultAssay(object = Control1_seurat))\n\nYour default assay is RNA\n\n\nThe second slot is the one that contains the metadata for each cell. It is easily visualized as a table (the command head shows only the first 6 rows of the table):\n\nhead( Control1_seurat@meta.data )\n\n\nA data.frame: 6 × 4\n\n\n\norig.ident\nnCount_RNA\nnFeature_RNA\nCondition\n\n\n\n&lt;fct&gt;\n&lt;dbl&gt;\n&lt;int&gt;\n&lt;chr&gt;\n\n\n\n\nAAACCCAAGGGCAGTT-1\nControl1_seurat\n3567\n1919\nControl\n\n\nAAACCCAAGTCAGCGA-1\nControl1_seurat\n7015\n2751\nControl\n\n\nAAACCCACACTAACCA-1\nControl1_seurat\n1484\n828\nControl\n\n\nAAACCCACATGATCTG-1\nControl1_seurat\n20942\n4711\nControl\n\n\nAAACCCAGTAGCTTGT-1\nControl1_seurat\n29105\n5157\nControl\n\n\nAAACCCAGTCTCTCAC-1\nControl1_seurat\n6115\n2124\nControl\n\n\n\n\n\nThe table contains a name for the dataset (orig.ident, useful to distinguish multiple datasets merged together), how many RNA transcripts are contained in each cell (nCount_RNA), the number of expressed genes in each cell (nFeature_RNA), and the Condition (added by us previously). More metadata can be added along the analysis, and some is added automatically by Seurat when running specific commands.\nThe assays and meta.data slots are the most relevant and useful to know - the other ones are mostly for internal use by Seurat and we do not go into detail with those."
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#finding-filtering-criteria",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#finding-filtering-criteria",
    "title": "Single Cell Analysis Tutorial",
    "section": "2.4 Finding filtering criteria",
    "text": "2.4 Finding filtering criteria\nWe want to look in depth at which droplets do not contain good quality data, so that we can filter them out. The standard approach - which works quite well - is to study the distribution of various quality measures and remove doublets (droplets containing more than one cell) which can confound the analysis results. We will look at some plots and decide some threshold, then we will apply them at the end after looking at all the histograms.\n\n2.4.1 Quality measure distributions\nA first step is to calculate the percentage of mitochondrial and chloroplastic genes. A high percentage indicates the presence of spilled material from broken cells. We use the command PercentageFeatureSet and provide the pattern of the gene ID which corresponds to mitochondrial and ribosomal genes. The percentages are saved into the metadata simply by using the double squared brackets [[.\n\nControl1_seurat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(Control1_seurat, \n                                                                 pattern = \"LotjaGiM1v\")\nControl1_seurat[[\"percent.chloroplast\"]] &lt;- PercentageFeatureSet(Control1_seurat, \n                                                                          pattern = \"LotjaGiC1v\")\n\nYou can see the new metadata is now added for each cell\n\nhead( Control1_seurat@meta.data )\n\n\nA data.frame: 6 × 6\n\n\n\norig.ident\nnCount_RNA\nnFeature_RNA\nCondition\npercent.mt\npercent.chloroplast\n\n\n\n&lt;fct&gt;\n&lt;dbl&gt;\n&lt;int&gt;\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nAAACCCAAGGGCAGTT-1\nControl1_seurat\n3567\n1919\nControl\n4.6818054\n0.02803476\n\n\nAAACCCAAGTCAGCGA-1\nControl1_seurat\n7015\n2751\nControl\n0.7127584\n0.04276550\n\n\nAAACCCACACTAACCA-1\nControl1_seurat\n1484\n828\nControl\n6.6037736\n0.06738544\n\n\nAAACCCACATGATCTG-1\nControl1_seurat\n20942\n4711\nControl\n0.4775093\n0.12415242\n\n\nAAACCCAGTAGCTTGT-1\nControl1_seurat\n29105\n5157\nControl\n0.2954819\n0.05497337\n\n\nAAACCCAGTCTCTCAC-1\nControl1_seurat\n6115\n2124\nControl\n1.6026165\n0.01635323\n\n\n\n\n\n\n2.4.1.1 Number of transcripts per cell\nWe plot a histogram of the number of transcripts per cell in Figure 7 below. On the right, we zoom into the histogram. We want to filter out the cells with the lowest number of transcripts - often there is a peak we can identify with a group of low-quality cells. Here we can choose to remove cells with less than ~700 transcripts (some people prefere to do a lighter filtering, and would for example set a threshold to a lower value). We remove also cells with too many transcripts that might contain some weird transcripts - which is also helpful for normalization because it removes some outlying values. For those we can set a limit to 30000, where there is a very thin tail in the histogram.\n\noptions(repr.plot.width=14, repr.plot.height=5)\n\nplot1 &lt;- ggplot(Control1_seurat@meta.data, aes(x=nCount_RNA)) + \n     geom_histogram(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9)\n\nplot2 &lt;- ggplot(Control1_seurat@meta.data, aes(x=nCount_RNA)) + \n     geom_histogram(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) +\n     xlim(0,2000)\n\nplot1 + plot2\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nWarning message:\n“Removed 7668 rows containing non-finite values (`stat_bin()`).”\nWarning message:\n“Removed 2 rows containing missing values (`geom_bar()`).”\n\n\n\n\n\nFigure 7: Histogram of transcripts per cell (left) and a zoom onto the histogram (right)\n\n\n\n\n\n\n2.4.1.2 Number of detected genes per cell\nHere we work similarly to filter out cells based on how many genes are detected (Figure 8). The right-side plot is a zoom into the histogram. It seems easy to set the thresholds at ~400 and ~7000 detected genes.\n\noptions(repr.plot.width=14, repr.plot.height=5)\n\nplot1 &lt;- ggplot(Control1_seurat@meta.data, aes(x=nFeature_RNA)) + \n     geom_histogram(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9)\n\nplot2 &lt;- ggplot(Control1_seurat@meta.data, aes(x=nFeature_RNA)) + \n     geom_histogram(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) +\n     xlim(0,1000)\n\n\nplot1 + plot2\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nWarning message:\n“Removed 7793 rows containing non-finite values (`stat_bin()`).”\nWarning message:\n“Removed 2 rows containing missing values (`geom_bar()`).”\n\n\n\n\n\nFigure 8: Histogram of detected counts per cell (left) and a zoom onto the histogram (right)\n\n\n\n\n\n\n2.4.1.3 Mitochondrial and Chloroplast percentages\nThe percentages of mitochondrial and chloroplastic transcripts tells us the data is of good quality, since most cells have low values of those (Figure 9). Thresholds are usually set between 5% and 20% in single cell data analysis. In the paper, thresholds were for example set at 20%.\n\noptions(repr.plot.width=14, repr.plot.height=5)\n\nplot1 &lt;- ggplot(Control1_seurat@meta.data, aes(x=percent.mt)) + \n     geom_histogram(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9)\n\nplot2 &lt;- ggplot(Control1_seurat@meta.data, aes(x=percent.chloroplast)) + \n     geom_histogram(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9)\n\nplot1 + plot2\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nFigure 9: Histogram of mitochondrial (left) and chloroplastic (right) percentage of transcripts in each cell\n\n\n\n\n\n\n2.4.1.4 Counts-Features relationship\nIn Figure 10 below, we look at the plot of the number of transcripts per cell vs the number of detected genes per cell. Usually, those two measure grow simultaneously. At lower counts the relationship is quite linear, then becomes a curve, typically bending in favour of the number of transcripts per cell. You can see below that each dot (representing a droplet) is coloured by percentage of mitochondria. Droplets with a high percentage of mitochondrial genes also have very low amount of transcripts and detected genes, confirming that high mitochondrial content is a measure of low quality.\n\noptions(repr.plot.width=14, repr.plot.height=5)\n\nmeta &lt;- Control1_seurat@meta.data %&gt;% arrange(percent.mt)\n\nplot1 &lt;- ggplot( meta, aes(x=nCount_RNA, y=nFeature_RNA, colour=percent.mt)) + \n         geom_point(alpha=0.75, size=5)+\n         geom_smooth(se=TRUE, method=\"loess\")\n\nplot1\n\n`geom_smooth()` using formula = 'y ~ x'\nWarning message:\n“The following aesthetics were dropped during statistical transformation: colour\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?”\n\n\n\n\n\nFigure 10: Histogram of the relationship between detected genes and transcripts per cell, coloured by mitochondrial content.\n\n\n\n\nIn a similar way the chloroplastic genes confirm the pattern of low quality droplets.\n\noptions(repr.plot.width=14, repr.plot.height=5)\n\nmeta &lt;- Control1_seurat@meta.data %&gt;% arrange(percent.chloroplast)\n\nplot1 &lt;- ggplot( meta, aes(x=nCount_RNA, y=nFeature_RNA, colour=percent.chloroplast)) + \n         geom_point(alpha=0.75, size=5)+\n         geom_smooth(se=TRUE, method=\"loess\")\n\nplot1\n\n`geom_smooth()` using formula = 'y ~ x'\nWarning message:\n“The following aesthetics were dropped during statistical transformation: colour\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?”\n\n\n\n\n\nFigure 11: Histogram of the relationship between detected genes and transcripts per cell, coloured by chloroplastic content.\n\n\n\n\n\n\n\n2.4.2 Filtering with the chosen criteria\nHere we use the command subset and impose the criteria we chose above looking at the histograms. We set each criteria for keeping cells of good quality using the names of the features in metadata. We print those names to remember them.\n\ncat(\"Meta data names:\\n\")\ncat( names(Control1_seurat@meta.data), sep='; ' )\n\nMeta data names:\norig.ident; nCount_RNA; nFeature_RNA; Condition; percent.mt; percent.chloroplast\n\n\nThe filtered object is called Control1_seurat_filt\n\nControl1_seurat_filt &lt;- subset(x = Control1_seurat, \n                                        subset = nCount_RNA &gt; 700 &\n                                                 nCount_RNA &lt; 35000 &\n                                                 nFeature_RNA &gt; 400 & \n                                                 nFeature_RNA &lt; 7000 & \n                                                 percent.mt &lt; 5 & \n                                                 percent.chloroplast &lt; 5)\n\ncat(\"Filtered Genes and Cells: \")\ncat( dim(Control1_seurat) - dim(Control1_seurat_filt) )\ncat(\"\\nRemaining Genes and Cells: \")\ncat( dim(Control1_seurat_filt) )\n\nFiltered Genes and Cells: 0 2762\nRemaining Genes and Cells: 23838 8010\n\n\nNow the transcripts vs genes can be seen in Figure 12. The relationship is much more linear than previously after the removal of extreme values for transcripts and detected genes.\n\noptions(repr.plot.width=14, repr.plot.height=5)\n\nmeta &lt;- Control1_seurat_filt@meta.data %&gt;% arrange(percent.mt)\n\nplot1 &lt;- ggplot( meta, aes(x=nCount_RNA, y=nFeature_RNA, colour=percent.mt)) + \n         geom_point(alpha=0.75, size=5)+\n         geom_smooth(se=TRUE, method=\"loess\")\n\nplot1\n\n`geom_smooth()` using formula = 'y ~ x'\nWarning message:\n“The following aesthetics were dropped during statistical transformation: colour\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?”\n\n\n\n\n\nFigure 12: Count vs features after filtering with the chosen criteria"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#normalization",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#normalization",
    "title": "Single Cell Analysis Tutorial",
    "section": "2.5 Normalization",
    "text": "2.5 Normalization\nscRNA-seq data is affected by highly variable RNA quantities and qualities across different cells. Furthermore, it is often subject to batch effects, sequencing depth differences, and other technical biases that can confound downstream analyses.\nNormalization methods are used to adjust for these technical variations so that true biological differences between cells can be accurately identified.\nSome commonly used normalization methods in scRNA-seq data include the following:\n\nTotal count normalization: Normalizing the read counts to the total number of transcripts in each sample\nTPM (transcripts per million) normalization: Normalizing the read counts to the total number of transcripts in each sample, scaled to a million\nLibrary size normalization: Normalizing the read counts to the total number of reads or transcripts in each sample, adjusted for sequencing depth\n\nAll the above suffer from distorting some gene expressions, especially if the data varies a lot in term of sequencing depth. A new and more advanced method, at the moment the state-of-the-art, is SCTransform (Hafemeister and Satija (2019)), a software package that can correct for technical sources of variation and remove batch effects.\n\n2.5.1 Finding technical sources of variation\nBefore normalizing we want to check for technical sources of variation in the data. One of those is the total number of transcripts: two similar cells might be sequenced at different depth. This influences of course normalization. The influence of the number of transcripts per cell is however always removed by SCtransform.\nWe want to look into other possible sources of variation. Those are usually quantities we calculate for each cell, for example the percentage of mitochondrial and chloroplastic genes.\nTo see if those quantities actually influence our data a lot, we check how much is their highest correlation with the first 10 components of the PCA of the dataset. In short, we see if any technical variation is such that it explains much of the variability of the data, covering possibly biological signal.\nWe now use the function plotCorrelations to plot the highest correlation of three quantities with the PCA: number of transcripts, percent of mitochondrial genes and percent of chloroplastic genes. You will see in Figure 13 how there is little correlation for the two percentages, for which we do not need to worry about, while there is correlation with the total number of transcripts per cell (this is always expected and, as mentioned before, is removed automatically by the normalization process). We created the function plotCorrelations specifically for the course, together with a few others, mostly for plotting or handling tables. You can find them in the file script.R.\n\n\nplotCorrelations( object=Control1_seurat, measures=c('nCount_RNA', 'percent.mt', 'percent.chloroplast') )\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n(a) Relationships of maximal correlation between cell quantities and principal components\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n(c)\n\n\n\nFigure 13: ?(caption)\n\n\n\n\n2.5.2 Executing normalization\nWe run SCtransform normalization below. Here you can choose to subsample some cells to do the normalization (ncells option): this is useful to avoid ending up waiting for a long time. A few thousands cells is enough.\nYou can also choose how many genes to consider for normalization (variable.features.n option): in this case it is best to use the genes that vary the most their expression across cells. We look at a histogram (Figure 14) of the variance of each gene to choose a threshold to identify highly-variable genes.\n\nvariance_genes &lt;- apply( as.matrix(Control1_seurat_filt[['RNA']]@counts), 1, var)\n\noptions(repr.plot.width=14, repr.plot.height=5)\n\nplot1 &lt;- ggplot(data.frame(variance_genes), aes(variance_genes)) + \n     geom_histogram(fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) + xlim(0,1)\n\nplot1\n\nWarning message in asMethod(object):\n“sparse-&gt;dense coercion: allocating vector of size 1.4 GiB”\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nWarning message:\n“Removed 3289 rows containing non-finite values (`stat_bin()`).”\nWarning message:\n“Removed 2 rows containing missing values (`geom_bar()`).”\n\n\n\n\n\nFigure 14: Histogram of genes variance. We choose the threshold 0.1 to identify highly variable genes.\n\n\n\n\n\nhvighly_var_genes &lt;- variance_genes &gt; .25\ncat(\"The total number of highly variable genes selected is: \")\ncat(sum( hvighly_var_genes ))\n\nThe total number of highly variable genes selected is: 6652\n\n\n\nControl1_seurat_norm &lt;- SCTransform(Control1_seurat_filt, \n                                             return.only.var.genes = FALSE, \n                                             ncells = 3000, \n                                             variable.features.n = sum( hvighly_var_genes ),\n                                             verbose = FALSE)\n\nNormalized data is now in the object Control1_seurat_norm, in a new assay called SCT. This assay is now the default used for data analysis: you can verify it very easily below:\n\ncat(\"Your default assay is: \")\ncat(DefaultAssay(object = Control1_seurat_norm))\n\nYour default assay is: SCT\n\n\n\n\n2.5.3 Visualizing the result\nNow we plot the UMAP plot of the data to have a first impression of how the data is structured (presence of clusters, how many, etc.). First of all, we create a PCA plot, which tells us how many PCA components are of relevance with the elbow plot of Figure 15. In the elbow plot, we see the variability of each component in descending order. Note how, after a few rapidly descending components, there is an elbow. We schoose a threshold just after the elbow (for example at 15), which means those components will be used to calculate some other things of relevance in the data, such as distance between cells and the UMAP projection of Figure 16: specific commands using PCA allow to choose the components, and we will set 10 with the option dims = 1:15.\n\nControl1_seurat_norm &lt;- FindVariableFeatures(Control1_seurat_norm,\n                                                     nfeatures = sum( hvighly_var_genes ))\n\n\nControl1_seurat_norm &lt;- RunPCA(object = Control1_seurat_norm, \n                                        verbose = FALSE, seed.use = 123)\n\n\nElbowPlot(Control1_seurat_norm, ndims = 30)\n\n\n\n\nFigure 15: Elbow plot of the first 30 principal components calculated from the data\n\n\n\n\nWe calculate the projection using the UMAP algorithm (McInnes et al. (2018), Becht et al. (2019)). The parameters a and b will change how stretched and scattered the data looks like. When you do your own UMAP projection, you can avoid setting a and b, and those will be chosen automatically by the command.\n\nControl1_seurat_norm &lt;- RunUMAP(object = Control1_seurat_norm, \n                                         a = .8, b=1,\n                                         dims = 1:15, \n                                         verbose = FALSE, \n                                         seed.use = 123)\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'spam'\n\nAlso defined by ‘BiocGenerics’\n\nFound more than one class \"dist\" in cache; using the first, from namespace 'spam'\n\nAlso defined by ‘BiocGenerics’\n\n\n\nIn Figure 16 we can see the resulting projection. The result looks pretty neat and structured (we can clearly see there are various clusters).\n\noptions(repr.plot.width=10, repr.plot.height=8)\nUMAPPlot(object = Control1_seurat_norm)\n\n\n\n\nFigure 16: UMAP projection of the data"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#removing-doublets",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#removing-doublets",
    "title": "Single Cell Analysis Tutorial",
    "section": "2.6 Removing doublets",
    "text": "2.6 Removing doublets\nDoublets removal is part of filtering, but it needs normalized data to work. This is why we do it after using SCtransform.\nDoublets (and the very rare multiplets) refer to droplets that contain the transcriptional profiles of two or more distinct cells. Doublets can occur during the cell dissociation process or when two or more cells are captured in the same droplet during the library preparation step.\nIt is quite obvious that a doublet transcriptional profile can confound downstream analyses, such as cell clustering and differential gene expression analysis. Most doublet detectors, like DoubletFinder (McGinnis, Murrow, and Gartner (2019)) which we will use, simulates doublets and then finds cells in the data which are similar to the simulated doublets. Most such packages need an idea of the number/proportion of expected doublets in the dataset. As indicated from the Chromium user guide, expected doublet rates are about as follows:\n\n\n\nFigure 17: Table of expected doublet rates based on the number of cells.\n\n\nThe data we are using contained about 10000 cells per sample (as in the knee plot at the beginning), hence we can assume that it originates from around 18000 loaded cells and should have a doublet rate at about 7.6%.\n\n\n\n\n\n\nWarning\n\n\n\nDoublet prediction, like the rest of the filtering, should be run on each sample separately.\n\n\nHere, we apply DoubletFinder to predict doublet cells. Most parameters are quite standard, we mostly need to choose nExp (expected number of doublets), PCs (number of principal components to use), sct (use the normalized data). The last three option are not part of the package, but have been added by creating a slightly modified version (here) - they allow to use multiple cores and a subset of cells for calculations for a considerable speedup. However, the code takes some time to run, so be patient. There will be a lot of printout as well, but don’t worry.\n\nnExp &lt;- round(ncol(Control1_seurat_norm) * 0.076)  # expected doublet rate\n\n\nControl1_seurat_norm &lt;- doubletFinder_v3(Control1_seurat_norm,\n                                                  pN = 0.25, #proportion of doublets to simulate)\n                                                  pK = 0.09, \n                                                  nExp = nExp, \n                                                  PCs = 1:15, \n                                                  sct=TRUE, \n                                                  workers=8, \n                                                  future.globals.maxSize = 8*1024^13,\n                                                  seurat.ncells=3000)\n\nLoading required package: fields\n\nLoading required package: spam\n\nSpam version 2.8-0 (2022-01-05) is loaded.\nType 'help( Spam)' or 'demo( spam)' for a short introduction \nand overview of this package.\nHelp for individual functions is also obtained by adding the\nsuffix '.spam' to the function name, e.g. 'help( chol.spam)'.\n\n\nAttaching package: ‘spam’\n\n\nThe following object is masked from ‘package:stats4’:\n\n    mle\n\n\nThe following objects are masked from ‘package:base’:\n\n    backsolve, forwardsolve\n\n\nLoading required package: viridisLite\n\n\nTry help(fields) to get started.\n\nLoading required package: KernSmooth\n\nKernSmooth 2.23 loaded\nCopyright M. P. Wand 1997-2009\n\nLoading required package: sctransform\n\nCalculating cell attributes from input UMI matrix: log_umi\n\nVariance stabilizing transformation of count matrix of size 23388 by 10680\n\nModel formula is y ~ log_umi\n\nGet Negative Binomial regression parameters per gene\n\nUsing 2000 genes, 3000 cells\n\nFound 151 outliers - those will be ignored in fitting/regularization step\n\n\nSecond step: Get residuals using fitted parameters for 23388 genes\n\nComputing corrected count matrix for 23388 genes\n\nCalculating gene attributes\n\nWall clock passed: Time difference of 1.02049 mins\n\nDetermine variable features\n\nPlace corrected count matrix in counts slot\n\nCentering data matrix\n\nSet default assay to SCT\n\nPC_ 1 \nPositive:  LotjaGi2g1v0360900, LotjaGi5g1v0359500, LotjaGi6g1v0155900, LotjaGi6g1v0155800, LotjaGi3g1v0321700, LotjaGi3g1v0414900, LotjaGi3g1v0030500, LotjaGi5g1v0211100, LotjaGi3g1v0506700, LotjaGi4g1v0109600 \n       LotjaGi3g1v0009600, LotjaGi1g1v0539300, LotjaGi3g1v0450900, LotjaGi2g1v0269100, LotjaGi3g1v0010900, LotjaGi3g1v0530000, LotjaGi3g1v0373700, LotjaGi4g1v0137700, LotjaGi3g1v0380900, LotjaGi4g1v0309700 \n       LotjaGi1g1v0014300, LotjaGi5g1v0359400, LotjaGi6g1v0071000, LotjaGi3g1v0012400, LotjaGi3g1v0162300, LotjaGi3g1v0554100, LotjaGi1g1v0516900, LotjaGi2g1v0316800, LotjaGi2g1v0285600, LotjaGi2g1v0358600 \nNegative:  LotjaGi6g1v0254300, LotjaGi3g1v0068000, LotjaGi6g1v0286800-LC, LotjaGi1g1v0080000, LotjaGi5g1v0005800, LotjaGi5g1v0269800-LC, LotjaGi5g1v0293100-LC, LotjaGi3g1v0222100, LotjaGi1g1v0006200, LotjaGi6g1v0254700 \n       LotjaGi3g1v0358300, LotjaGi3g1v0329100, LotjaGi3g1v0445300, LotjaGi1g1v0646500-LC, LotjaGi2g1v0157900, LotjaGi3g1v0505900, LotjaGi1g1v0022100, LotjaGi4g1v0076500, LotjaGi4g1v0293000-LC, LotjaGi1g1v0558200 \n       LotjaGi1g1v0577100, LotjaGi3g1v0395900-LC, LotjaGi5g1v0031100, LotjaGi5g1v0288600, LotjaGi3g1v0097800, LotjaGi1g1v0261700, LotjaGi4g1v0207600, LotjaGi4g1v0313900, LotjaGi2g1v0303000, LotjaGi1g1v0515200 \nPC_ 2 \nPositive:  LotjaGi3g1v0358300, LotjaGi6g1v0254300, LotjaGi1g1v0646500-LC, LotjaGi3g1v0038800, LotjaGi6g1v0253800, LotjaGi6g1v0255000, LotjaGi1g1v0006200, LotjaGi6g1v0254700, LotjaGi5g1v0089300, LotjaGi6g1v0022500 \n       LotjaGi3g1v0329100, LotjaGi6g1v0043900, LotjaGi1g1v0261700, LotjaGi4g1v0313900, LotjaGi2g1v0303000, LotjaGi5g1v0005800, LotjaGi1g1v0277900, LotjaGi6g1v0022600, LotjaGi4g1v0325700, LotjaGi3g1v0222100 \n       LotjaGi1g1v0690000, LotjaGi6g1v0155800, LotjaGi4g1v0293000-LC, LotjaGi2g1v0360900, LotjaGi1g1v0555200, LotjaGi4g1v0284700, LotjaGi3g1v0046800, LotjaGi1g1v0336600, LotjaGi2g1v0239200, LotjaGi2g1v0388100 \nNegative:  LotjaGi5g1v0248500, LotjaGi1g1v0405300, LotjaGi1g1v0074900, LotjaGi1g1v0683300, LotjaGi2g1v0160200, LotjaGi4g1v0018700-LC, LotjaGi5g1v0163900, LotjaGi6g1v0315500, LotjaGi6g1v0078500, LotjaGi2g1v0221100 \n       LotjaGi2g1v0019900, LotjaGi4g1v0217400, LotjaGi5g1v0248600, LotjaGi4g1v0256800, LotjaGi2g1v0002800-LC, LotjaGi3g1v0204100, LotjaGi2g1v0426500, LotjaGi4g1v0297800, LotjaGi6g1v0246700, LotjaGi1g1v0109100 \n       LotjaGi1g1v0109000, LotjaGi3g1v0493400-LC, LotjaGi5g1v0159400, LotjaGi3g1v0086100-LC, LotjaGi5g1v0120700, LotjaGi1g1v0430800-LC, LotjaGi6g1v0292800, LotjaGi1g1v0593900, LotjaGi5g1v0249500, LotjaGi6g1v0216300 \nPC_ 3 \nPositive:  LotjaGi3g1v0445300, LotjaGi3g1v0505900, LotjaGi1g1v0594900, LotjaGi1g1v0502700, LotjaGi4g1v0275500, LotjaGi1g1v0723600-LC, LotjaGi6g1v0151500, LotjaGi4g1v0208100, LotjaGi5g1v0269800-LC, LotjaGi2g1v0163300 \n       LotjaGi6g1v0028000-LC, LotjaGi4g1v0207600, LotjaGi3g1v0115600, LotjaGi1g1v0475000-LC, LotjaGi2g1v0163500, LotjaGi4g1v0207900, LotjaGi1g1v0022100, LotjaGi1g1v0348000, LotjaGi2g1v0176500-LC, LotjaGi2g1v0406200 \n       LotjaGi5g1v0266100, LotjaGi2g1v0402200, LotjaGi3g1v0359600, LotjaGi3g1v0506700, LotjaGi6g1v0286800-LC, LotjaGi5g1v0211100, LotjaGi3g1v0414900, LotjaGi4g1v0014800, LotjaGi5g1v0296300-LC, LotjaGi1g1v0659300 \nNegative:  LotjaGi1g1v0405300, LotjaGi5g1v0248500, LotjaGi4g1v0018700-LC, LotjaGi1g1v0683300, LotjaGi1g1v0074900, LotjaGi5g1v0163900, LotjaGi3g1v0218300, LotjaGi2g1v0221100, LotjaGi2g1v0019900, LotjaGi6g1v0078500 \n       LotjaGi4g1v0217400, LotjaGi4g1v0256800, LotjaGi2g1v0160200, LotjaGi3g1v0204100, LotjaGi3g1v0068000, LotjaGi5g1v0248600, LotjaGi6g1v0253800, LotjaGi3g1v0038800, LotjaGi1g1v0109100, LotjaGi3g1v0493400-LC \n       LotjaGi6g1v0315500, LotjaGi3g1v0086100-LC, LotjaGi3g1v0358300, LotjaGi6g1v0246700, LotjaGi2g1v0002800-LC, LotjaGi5g1v0249500, LotjaGi6g1v0043900, LotjaGi2g1v0426500, LotjaGi2g1v0429600, LotjaGi6g1v0255000 \nPC_ 4 \nPositive:  LotjaGi5g1v0005800, LotjaGi1g1v0558200, LotjaGi5g1v0288600, LotjaGi3g1v0174100, LotjaGi3g1v0222100, LotjaGi3g1v0068000, LotjaGi2g1v0386600, LotjaGi5g1v0166000-LC, LotjaGi6g1v0286800-LC, LotjaGi3g1v0162600 \n       LotjaGi4g1v0121800, LotjaGi3g1v0395900-LC, LotjaGi2g1v0126700, LotjaGi5g1v0099800, LotjaGi4g1v0293000-LC, LotjaGi4g1v0431800, LotjaGi3g1v0178400, LotjaGi1g1v0636800, LotjaGi4g1v0076500, LotjaGi6g1v0012100 \n       LotjaGi2g1v0368200, LotjaGi1g1v0393600, LotjaGi1g1v0114400, LotjaGi4g1v0064700, LotjaGi5g1v0003500, LotjaGi1g1v0340500, LotjaGi3g1v0112700, LotjaGi3g1v0191200, LotjaGi6g1v0069200, LotjaGi3g1v0192300 \nNegative:  LotjaGi5g1v0269800-LC, LotjaGi5g1v0120700, LotjaGi3g1v0420400, LotjaGi2g1v0157900, LotjaGi1g1v0377600, LotjaGi6g1v0253800, LotjaGi6g1v0254700, LotjaGi5g1v0293100-LC, LotjaGi1g1v0613100, LotjaGi1g1v0646500-LC \n       LotjaGi1g1v0022100, LotjaGi2g1v0303000, LotjaGi3g1v0055400, LotjaGi2g1v0176500-LC, LotjaGi5g1v0119900, LotjaGi1g1v0515200, LotjaGi2g1v0163500, LotjaGi3g1v0445300, LotjaGi3g1v0420800, LotjaGi3g1v0046800 \n       LotjaGi3g1v0115400, LotjaGi3g1v0505900, LotjaGi1g1v0723600-LC, LotjaGi1g1v0690000, LotjaGi1g1v0475000-LC, LotjaGi4g1v0207600, LotjaGi3g1v0329100, LotjaGi1g1v0277900, LotjaGi4g1v0060000, LotjaGi3g1v0420000 \nPC_ 5 \nPositive:  LotjaGi3g1v0328800, LotjaGi3g1v0222100, LotjaGi4g1v0417500, LotjaGi3g1v0328900, LotjaGi2g1v0450600, LotjaGi3g1v0201800, LotjaGi4g1v0293000-LC, LotjaGi3g1v0378600, LotjaGi5g1v0166000-LC, LotjaGi1g1v0353400 \n       LotjaGi3g1v0395900-LC, LotjaGi6g1v0069200, LotjaGi6g1v0155800, LotjaGi6g1v0286800-LC, LotjaGi3g1v0546100, LotjaGi3g1v0445300, LotjaGi6g1v0326300, LotjaGi3g1v0162300, LotjaGi5g1v0288600, LotjaGi5g1v0031100 \n       LotjaGi1g1v0601700, LotjaGi3g1v0174100, LotjaGi1g1v0594900, LotjaGi5g1v0266100, LotjaGi3g1v0505900, LotjaGi4g1v0284700, LotjaGi1g1v0393600, LotjaGi6g1v0043900, LotjaGi4g1v0269400, LotjaGi1g1v0795300 \nNegative:  LotjaGi4g1v0121800, LotjaGi3g1v0068000, LotjaGi5g1v0099800, LotjaGi3g1v0178400, LotjaGi2g1v0368200, LotjaGi6g1v0012100, LotjaGi1g1v0114400, LotjaGi2g1v0452500, LotjaGi1g1v0240900-LC, LotjaGi5g1v0003500 \n       LotjaGi3g1v0192300, LotjaGi2g1v0301500, LotjaGi4g1v0300800-LC, LotjaGi3g1v0162600, LotjaGi5g1v0120700, LotjaGi5g1v0102500, LotjaGi4g1v0298100, LotjaGi5g1v0100000, LotjaGi3g1v0506700, LotjaGi2g1v0345700 \n       LotjaGi1g1v0137600, LotjaGi3g1v0001800, LotjaGi1g1v0760600, LotjaGi5g1v0094100, LotjaGi1g1v0221300, LotjaGi4g1v0431800, LotjaGi4g1v0455200, LotjaGi6g1v0232200, LotjaGi4g1v0064700, LotjaGi1g1v0300600 \n\n\n\n[1] \"Creating 2670 artificial doublets...\"\n[1] \"Creating Seurat object...\"\n[1] \"Running SCTransform...\"\n  |======================================================================| 100%\n  |======================================================================| 100%\n  |======================================================================| 100%\n[1] \"Running PCA...\"\n[1] \"Calculating PC distance matrix...\"\n[1] \"Computing pANN...\"\n[1] \"Classifying doublets..\"\n\n\nWe visualize the UMAP plot and which cells are estimated doublets in Figure 18. Fortunately, there are only a few potential doublets.\n\noptions(repr.plot.width=10, repr.plot.height=10)\n\nDF.name = colnames(Control1_seurat_norm@meta.data)[grepl(\"DF.classification\", colnames(Control1_seurat_norm@meta.data))]\n\nDimPlot(Control1_seurat_norm, group.by = DF.name, pt.size = 2, \n        split.by = DF.name)\n\n\n\n\nFigure 18: UMAP projection of the data coloured by doublet or singlet label\n\n\n\n\nSometimes doublets have more detected genes than a single cell. In our case, some of the droplets have higher number of genes than the average (the red violin is large also above 3000 detected genes), so there is aclear sign of the presence of some doublets. Of course, as with any filtering, we might remove some actual cells. To be more effective in our filtering, we can select doublets with more than 2000 detected genes when we filter.\n\nVlnPlot(Control1_seurat_norm, features = \"nFeature_RNA\", group.by = DF.name, pt.size = 0.1)\n\n\n\n\nHere we keep only singlets:\n\nControl1_seurat_norm = Control1_seurat_norm[, (Control1_seurat_norm@meta.data[, DF.name] == \"Singlet\")&(Control1_seurat_norm@meta.data$nFeature_RNA&gt;2000)]\n\nWe save our data after all the filtering work!\n\nSaveH5Seurat(object = Control1_seurat_norm, \n             filename = \"control1.normalized.h5Seurat\", \n             overwrite = TRUE,\n             verbose = FALSE)\n\nWarning message:\n“Overwriting previous file control1.normalized.h5Seurat”\nCreating h5Seurat file for version 3.1.5.9900"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#clustering-and-cell-type-assignment",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#clustering-and-cell-type-assignment",
    "title": "Single Cell Analysis Tutorial",
    "section": "3.1 Clustering and cell type assignment",
    "text": "3.1 Clustering and cell type assignment\nWe perform clustering on the data using the leiden algorithm (blondel_fast_2008, Traag, Waltman, and Van Eck (2019)). Then, we look at a typical strategy of naming clusters by visualizing known markers. Since this is very subjective and biased, we then resort to naming cell types using a reference annotated dataset. An overview of cell type assignment procedures can be found at Cheng et al. (2023).\n\nseurat.integrated &lt;-  LoadH5Seurat(\"seurat.integrated.h5Seurat\", verbose=FALSE)\n\nValidating h5Seurat file\n\nWarning message:\n“Adding a command log without an assay associated with it”\n\n\nClustering function FindClusters. The resolution is used to change the number of clusters detected. We do not need many, so we set on to 0.5. Usual values range between 0.1 and 1.\n\nseurat.integrated &lt;- FindClusters(object = seurat.integrated, \n                                  resolution = .5,\n                                  random.seed = 123)\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 20572\nNumber of edges: 1140129\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9378\nNumber of communities: 20\nElapsed time: 2 seconds\n\n\nWarning message:\n“UNRELIABLE VALUE: One of the ‘future.apply’ iterations (‘future_lapply-1’) unexpectedly generated random numbers without declaring so. There is a risk that those random numbers are not statistically sound and the overall results might be invalid. To fix this, specify 'future.seed=TRUE'. This ensures that proper, parallel-safe random numbers are produced via the L'Ecuyer-CMRG method. To disable this check, use 'future.seed = NULL', or set option 'future.rng.onMisuse' to \"ignore\".”\n\n\nThe clusters are saved in the meta data table as integrated_snn_res.0.25. Note that the name changes with the resolution. Also observe how much metadata we have: many columns come from tools we have applied, such as doubletfinder (DF) and nearest neighbor distances (snn).\n\nhead( seurat.integrated@meta.data )\n\n\nA data.frame: 6 × 16\n\n\n\nnCount_RNA\nnFeature_RNA\nnCount_SCT\nnFeature_SCT\norig.ident\nCondition\npercent.mt\npercent.chloroplast\npANN_0.25_0.09_609\nDF.classifications_0.25_0.09_609\npANN_0.25_0.09_329\nDF.classifications_0.25_0.09_329\npANN_0.25_0.09_309\nDF.classifications_0.25_0.09_309\nintegrated_snn_res.0.5\nseurat_clusters\n\n\n\n&lt;dbl&gt;\n&lt;int&gt;\n&lt;dbl&gt;\n&lt;int&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;fct&gt;\n&lt;fct&gt;\n\n\n\n\nAAACCCACATGATCTG-1_1\n20942\n4711\n11291\n4192\nControl1_seurat\nControl\n0.4775093\n0.12415242\n0.2299688\nSinglet\nNA\nNA\nNA\nNA\n8\n8\n\n\nAAACCCAGTAGCTTGT-1_1\n29105\n5157\n10486\n3382\nControl1_seurat\nControl\n0.2954819\n0.05497337\n0.2695109\nSinglet\nNA\nNA\nNA\nNA\n10\n10\n\n\nAAACCCAGTCTCTCAC-1_1\n6115\n2124\n10086\n2163\nControl1_seurat\nControl\n1.6026165\n0.01635323\n0.1904266\nSinglet\nNA\nNA\nNA\nNA\n0\n0\n\n\nAAACCCATCACCTTGC-1_1\n7410\n2988\n10003\n2985\nControl1_seurat\nControl\n0.5263158\n0.09446694\n0.2466181\nSinglet\nNA\nNA\nNA\nNA\n18\n18\n\n\nAAACGAAAGTCCTGTA-1_1\n5616\n2034\n9866\n2097\nControl1_seurat\nControl\n0.7122507\n0.10683761\n0.2382934\nSinglet\nNA\nNA\nNA\nNA\n17\n17\n\n\nAAACGAAAGTGTGTTC-1_1\n12580\n3329\n11180\n3328\nControl1_seurat\nControl\n0.1510334\n0.06359300\n0.2559834\nSinglet\nNA\nNA\nNA\nNA\n18\n18\n\n\n\n\n\nWe can plot the clusters in the UMAP plot\n\noptions(repr.plot.width=10, repr.plot.height=8)\nDimPlot(object = seurat.integrated, reduction = \"umap\",  label = T, repel = TRUE, pt.size = 0.5)\n\n\n\n\nFigure 21: UMAP of the integrated datasets with clusters (still unassigned to cell types).\n\n\n\n\n\n3.1.1 Cluster assignment from visualized marker scores\nHere, we look at how to assign names based on known markers. In this procedure, biological knowledge of the cell types is needed. Below, there is a list of known markers for each cell type, extracted from the supplementary data of Frank et al. (2023).\n\nfeatures_list &lt;- list(\n    'Cortex_scoring' = c(\"LotjaGi1g1v0006200\",\n                 \"LotjaGi1g1v0022100\",\n                 \"LotjaGi1g1v0261700\",\n                 \"LotjaGi1g1v0348000\",\n                 \"LotjaGi2g1v0303000\",\n                 \"LotjaGi3g1v0505900\"),\n    'Epidermis_scoring' = c(\"LotjaGi1g1v0080000\",\n                    \"LotjaGi1g1v0377600\",\n                    \"LotjaGi1g1v0613100\",\n                    \"LotjaGi3g1v0070500\"),\n    'Endodermis_scoring' = c(\"LotjaGi1g1v0114400\",\n                     \"LotjaGi1g1v0221300\",\n                     \"LotjaGi1g1v0240900-LC\",\n                     \"LotjaGi1g1v0707500\"), \n    'RootCap_scoring' = c(\"LotjaGi1g1v0020900\",\n                   \"LotjaGi1g1v0039700-LC\",\n                   \"LotjaGi1g1v0040300\",\n                   \"LotjaGi1g1v0147500\"),  \n    'Meristem_scoring'= c(\"LotjaGi4g1v0300900\",\n                         \"LotjaGi6g1v0056500\",\n                         \"LotjaGi1g1v0594200\"),\n    'Phloem_scoring'= c(\"LotjaGi1g1v0028800\",\n                \"LotjaGi1g1v0085900\",\n                \"LotjaGi1g1v0119300\",\n                \"LotjaGi1g1v0149100\"),\n    'QuiescentCenter_scoring' = c(\"LotjaGi1g1v0004300\",\n                           \"LotjaGi1g1v0021400\",\n                           \"LotjaGi1g1v0052700\",\n                           \"LotjaGi1g1v0084000\"),\n    'RootHair_scoring'= c(\"LotjaGi1g1v0014300\",\n                   \"LotjaGi1g1v0109000\",\n                   \"LotjaGi1g1v0109100\",\n                   \"LLotjaGi1g1v0143900\"),  \n    'Pericycle_scoring'= c(\"LotjaGi3g1v0222100\",\n                   \"LotjaGi3g1v0395900-LC\",\n                   \"LotjaGi5g1v0166000-LC\",\n                   \"LotjaGi3g1v0395500-LC\",\n                   \"LotjaGi1g1v0783700-LC\",\n                   \"LotjaGi2g1v0333200\",\n                   \"LotjaGi4g1v0293000-LC\"),     \n    'Stele_scoring' = c(\"LotjaGi2g1v0126700\",\n                \"LotjaGi1g1v0558200\",\n                \"LotjaGi4g1v0215500\",\n                \"LotjaGi3g1v0174100\",\n                \"LotjaGi5g1v0288600\",\n                \"LotjaGi3g1v0129700\"),\n    'Xylem_scoring' = c(\"LotjaGi1g1v0623100\",\n                \"LotjaGi1g1v0569300\",\n                \"LotjaGi1g1v0443000\",\n                \"LotjaGi1g1v0428800\")\n    )\n\nHere, we need a function calculating the scores for each cell type. This is the average expression of the markers in the list, from which we remove the average expression of some control genes, which are supposed not to be specific for the cell type of interest. The cells matching the desired type should retain a high score.\n\nseurat.clustered &lt;- AddModuleScore(\n  object = seurat.integrated,\n  features = features_list,\n  ctrl = 5,\n  name = 'LJ_scores'\n)\n\nWarning message:\n“The following features are not present in the object: LotjaGi1g1v0085900, not searching for symbol synonyms”\nWarning message:\n“The following features are not present in the object: LLotjaGi1g1v0143900, not searching for symbol synonyms”\nWarning message:\n“The following features are not present in the object: LotjaGi3g1v0129700, not searching for symbol synonyms”\n\n\nWe also apply a function (from script.R) to rename the scores in the metadata. Their names are not intuitive by default, they are all called with the name chosen above and a number after it:\n\nnames(seurat.clustered@meta.data)\n\n\n'nCount_RNA''nFeature_RNA''nCount_SCT''nFeature_SCT''orig.ident''Condition''percent.mt''percent.chloroplast''pANN_0.25_0.09_609''DF.classifications_0.25_0.09_609''pANN_0.25_0.09_329''DF.classifications_0.25_0.09_329''pANN_0.25_0.09_309''DF.classifications_0.25_0.09_309''integrated_snn_res.0.5''seurat_clusters''LJ_scores1''LJ_scores2''LJ_scores3''LJ_scores4''LJ_scores5''LJ_scores6''LJ_scores7''LJ_scores8''LJ_scores9''LJ_scores10''LJ_scores11'\n\n\n\nseurat.clustered &lt;- renameScores(markers_list = features_list, seurat_data = seurat.clustered)      \n\nScores renamed FROM\n\n\n\n\nTO\n\n\n\n\n\n\nLJ_scores1\nLJ_scores2\nLJ_scores3\nLJ_scores4\nLJ_scores5\nLJ_scores6\nLJ_scores7\nLJ_scores8\nLJ_scores9\nLJ_scores10\nLJ_scores11\nCortex_scoring\nEpidermis_scoring\nEndodermis_scoring\nRootCap_scoring\nMeristem_scoring\nPhloem_scoring\nQuiescentCenter_scoring\nRootHair_scoring\nPericycle_scoring\nStele_scoring\nXylem_scoring\n\n\nNow we run the function plotScoresUMAP (from the file script.R). In Figure 22 we can see that some clusters are easy to classify (phloem and xylem), but many others are not. This is mainly due to the fact that the change of many cell types is a continuum, and this manual annotation is very subjective.\n\nplotScoresUMAP(markers_list = features_list, seurat_data = seurat.clustered)                                  \n\n\n\n\nFigure 22: Scores of the list of markers for the Lotus Japonicus clusters. Those should help identifying cell types by plotting the average of markers subtracted the average of other random genes in the data.\n\n\n\n\nOne easy solution is to use the highest scoring of each cluster to assign the cluster name. Below, in the function clusterNames, for each cluster, we sum the scores of each cell type, and the highest value decides the cluster name.\n\n#use the clustering above\nIdents(seurat.clustered) &lt;- 'integrated_snn_res.0.5' \n#assign names\nseurat.clustered@meta.data[\"Cell_types\"] &lt;- clusterNames(seurat.clustered, features_list)\n#use the new names as clustering labels\nIdents(seurat.clustered) &lt;- 'Cell_types'\n\nCluster assignment started\n\n--- QuiescentCenter assigned to 8\n\n--- RootHair assigned to 10\n\n--- RootCap assigned to 0\n\n--- Meristem assigned to 18\n\n--- Phloem assigned to 17\n\n--- Pericycle assigned to 4\n\n--- Stele assigned to 13\n\n--- Endodermis assigned to 2\n\n--- Epidermis assigned to 12\n\n--- Cortex assigned to 5\n\n--- Epidermis assigned to 7\n\n--- Epidermis assigned to 6\n\n--- Pericycle assigned to 3\n\n--- Xylem assigned to 19\n\n--- Cortex assigned to 1\n\n--- RootCap assigned to 16\n\n--- RootHair assigned to 11\n\n--- Cortex assigned to 9\n\n--- Epidermis assigned to 14\n\n--- Endodermis assigned to 15\n\nCluster assignment finished\n\n\n\n\n\n\n\n\n\nManual assignment\n\n\n\nIf you wanted to manually assign cell types, then you could use the command RenameIdents, for example\nIdents(seurat.clustered) &lt;- 'integrated_snn_res.0.5'\n\nseurat.clustered &lt;- RenameIdents(object = seurat.clustered,\n                               \"2\"=\"Cortex\", \"5\"=\"Cortex\", \"11\"=\"Cortex\",\n                               \"6\"=\"Epidermis\", \"12\"=\"Epidermis\", \"7\"=\"Epidermis\",\n                               \"15\"=\"Endodermis\",  \n                               \"0\"=\"Root_Cap\", \"13\"=\"Root_Cap\",\n                               \"16\"=\"Meristem\",  \n                               \"17\"=\"Phloem\",\n                               \"10\"=\"Root_Hair\", \"9\"=\"Root_Hair\",\n                               \"1\"=\"PericycleStele\", \n                               \"3\"=\"Pericycle\", \"19\"=\"Pericycle\",\n                               \"20\"=\"Xylem\")\n(the names do not match correctly the numbers of our clustering, they are just for the sake of the example)\n\n\nIt seems from Figure 23 that we have quite consistent clustering across the various cell types.\n\noptions(repr.plot.width=10, repr.plot.height=10)\nDimPlot(object = seurat.clustered, reduction = \"umap\", repel = TRUE, label=T, pt.size = 2, label.size = 5)\n\n\n\n\nFigure 23: UMAP of the integrated datasets with clusters assigned by looking at markers scores and using a function to assign score-based names. Note that there are a few cells here and there that are not labelled correctly, which often happens as a few datapoints are noisy.\n\n\n\n\n\n3.1.1.1 Optional: assigning a mixed cluster\nConsider the marker plots for pericycle and Stele cell types in Figure 22. Here you can see overlap of the markers, which is not unnormal, since biological processes often transition gradually and eventually share some markers. We can try to separate the two cell types more precisely by assigning the cell type to each single data point, by comparing its score for Pericycle and Stele, instead of renaming each cluster as a whole.\nThe code below runs such comparison for each cell in the pericycle and stele clusters.\n\nperi &lt;- seurat.clustered@meta.data$Pericycle_scoring[ seurat.clustered@meta.data$Cell_types == 'Pericycle' | seurat.clustered@meta.data$Cell_types == 'Stele']\nstel &lt;- seurat.clustered@meta.data$Stele_scoring[ seurat.clustered@meta.data$Cell_types == 'Pericycle' | seurat.clustered@meta.data$Cell_types == 'Stele' ]\nperi_stele &lt;- peri&gt;=stel\nfinalcl = c()\nfor(i in peri_stele)\n    finalcl = c(finalcl, ifelse(i, \"Pericycle\", \"Stele\"))\n\ncelltypes &lt;- seurat.clustered@meta.data$Cell_types\ncelltypes[ seurat.clustered@meta.data$Cell_types == 'Pericycle' | seurat.clustered@meta.data$Cell_types == 'Stele' ] &lt;- finalcl\nseurat.clustered@meta.data$Cell_types &lt;- celltypes\nIdents(seurat.clustered) &lt;- 'Cell_types'\n\n\noptions(repr.plot.width=10, repr.plot.height=10)\nDimPlot(object = seurat.clustered, reduction = \"umap\", repel = TRUE, label=T, pt.size = 2, label.size = 5)\n\n\n\n\nFigure 24: UMAP of the integrated datasets with clusters assigned by refining Pericycle and Stele.\n\n\n\n\n\n\n\n3.1.2 Cluster assignment from an annotated dataset\nWe now use the annotated data from Frank et al. (2023) (which is the same we are using in the tutorial) to transfer data labels to our own processed data. More about label transfer can be read at Stuart et al. (2019). We load the data from the paper and define reference and query data.\n\nseurat.reference &lt;- readRDS(\"../Data/data_lavinia.RDS\")\n\n\nseurat.query &lt;- seurat.clustered\n\nWe have to define the data integration between query and reference before we can transfer the cluster names. For the algorithm to work, we need to use the “RNA” assay, which contains raw expression values.\n\nDefaultAssay(seurat.query) &lt;- \"RNA\"\n\n\nlotusjaponicus.anchors &lt;- FindTransferAnchors(reference = seurat.reference, \n                                        features = intersect( rownames(seurat.query), \n                                                   rownames( seurat.reference[['SCT']]@scale.data ) ),\n                                        query = seurat.query, dims = 1:20, \n                                        reference.reduction = \"pca\",\n                                        reference.assay='RNA')\n\nProjecting cell embeddings\n\nFinding neighborhoods\n\nFinding anchors\n\n    Found 26902 anchors\n\nFiltering anchors\n\n    Retained 13016 anchors\n\n\n\nCalculating the integration of the labels from the reference takes time. So we save the calculated anchors for the integration. If you need to rerun the code, skip the command above and instead load the data with readRDS below.\n\nsaveRDS(lotusjaponicus.anchors, file = \"anchors.RDS\")\n\n\nlotusjaponicus.anchors &lt;- readRDS(\"anchors.RDS\")\n\nNow it is finally time to transfer the labels and add them to the metadata. The column in the metadata is called by default predicted.id.\n\npredictions &lt;- TransferData(anchorset = lotusjaponicus.anchors, \n                            refdata = Idents(seurat.reference), \n                            dims = 1:20)\n\nFinding integration vectors\n\nFinding integration vector weights\n\nPredicting cell labels\n\n\n\n\nseurat.clustered &lt;- AddMetaData(seurat.clustered, metadata = predictions['predicted.id'])\n\nJust as a reminder of what is in the metadata, we can quickly look at the column names. Those are ordered by when we added things along the analysis. If you read the names, you can recognize part of the analysis steps until now.\n\nnames( seurat.clustered@meta.data )\n\n\n'nCount_RNA''nFeature_RNA''nCount_SCT''nFeature_SCT''orig.ident''Condition''percent.mt''percent.chloroplast''pANN_0.25_0.09_609''DF.classifications_0.25_0.09_609''pANN_0.25_0.09_329''DF.classifications_0.25_0.09_329''pANN_0.25_0.09_309''DF.classifications_0.25_0.09_309''integrated_snn_res.0.5''seurat_clusters''Cortex_scoring''Epidermis_scoring''Endodermis_scoring''RootCap_scoring''Meristem_scoring''Phloem_scoring''QuiescentCenter_scoring''RootHair_scoring''Pericycle_scoring''Stele_scoring''Xylem_scoring''Cell_types''predicted.id'\n\n\nHere we define as clustering for the data and the plots, the one transfered just before. We then have a look at Figure 25 to observe that the labels look fine.\n\nIdents(seurat.clustered) &lt;- 'predicted.id'\n\n\noptions(repr.plot.width=10, repr.plot.height=10)\nDimPlot(object = seurat.clustered, \n        reduction = \"umap\", \n        repel = TRUE, label=T, \n        pt.size = 0.5, label.size = 10, )\n\n\n\n\nFigure 25: UMAP of the integrated datasets with cell types named through label transfer.\n\n\n\n\nWe save the data\n\nSaveH5Seurat(object = seurat.clustered, \n             filename = \"seurat.clustered.h5Seurat\", \n             overwrite = TRUE,\n             verbose=FALSE)\n\nWarning message:\n“Overwriting previous file seurat.clustered.h5Seurat”\nCreating h5Seurat file for version 3.1.5.9900"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#differential-gene-expression-dge",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#differential-gene-expression-dge",
    "title": "Single Cell Analysis Tutorial",
    "section": "4.1 Differential Gene Expression (DGE)",
    "text": "4.1 Differential Gene Expression (DGE)\nHere we test each cluster to see which are significantly more expressed genes in the infected samples compared to the wild-type samples. We also see if we find the gene RINRK1 as being significant. Again, the resulting genes can be useful to be integrated with the GO terms as we did before.\nWe first have a quick look to see how much the RINRK1 gene is expressed in the data. We use the RNA assay to plot the true expression values. The UMAP plot shows few cells expressing the genes, meaning its average expression is going to be very low, so it is likely we will not find the gene to be differentially expressed anywhere.\n\nRINRK1.id &lt;- 'LotjaGi1g1v0182900'\n\nDefaultAssay(seurat.clustered) &lt;- \"RNA\"\n\nFeaturePlot(seurat.clustered,\n            reduction = \"umap\", \n            features = c(RINRK1.id), \n            order = TRUE,\n            min.cutoff = 0, \n            pt.size = 1,\n            label = TRUE,\n            label.size = 7) + theme(legend.position = \"right\")\n\n\n\n\nFigure 26: UMAP plot for the expression of gene RINRK1 in the data\n\n\n\n\nFrom biological knowledge, we expect the gene mostly expressed in the cortex and trichoblasts upon inoculation with rhizobia, and that is what happens in our data as well. We can see it in the code and violin plot of Figure 27\n\ncat(\"Cells in inoculated L.J. expressing\", RINRK1.id, \"\\n\")\n\ncat( sum( as.numeric(GetAssayData(seurat.clustered[RINRK1.id,]))&gt;0 & \n     seurat.clustered@meta.data$Condition==\"R7A\" ) )\n\ncat(\"\\nCells in control L.J. expressing\", RINRK1.id, \"\\n\")\n\ncat( sum( as.numeric(GetAssayData(seurat.clustered[RINRK1.id,]))&gt;0 & \n    seurat.clustered@meta.data$Condition==\"Control\" ) )\n\nCells in inoculated L.J. expressing LotjaGi1g1v0182900 \n56\nCells in control L.J. expressing LotjaGi1g1v0182900 \n0\n\n\n\nVlnPlot(seurat.clustered, \n        features = RINRK1.id)\n\n\n\n\nFigure 27: Violin plot for the expression of gene RINRK1 in various clusters\n\n\n\n\nThe code below uses FindMarkers to compare R7A condition against Control for each cluster, with a filter to remove non-singnificant genes (keeping p-value below 0.001 and log fold change &gt; 1 and &lt; -1). We keep also genes expressed 30% more than in the condition where they are underexpressed. We use only the 2000 most variable genes, since we are interested in very variable gene expressions across data.\n\nseurat.clustered &lt;- FindVariableFeatures(seurat.clustered, nfeatures = 2000, assay = \"integrated\")\n\nWarning message:\n“Not all features provided are in this Assay object, removing the following feature(s): LotjaGi2g1v0240800, LotjaGi2g1v0095600, LotjaGi1g1v0324300, LotjaGi2g1v0394200, LotjaGi5g1v0341600, LotjaGi2g1v0130600-LC, LotjaGi6g1v0167000-LC, LotjaGi1g1v0358100, LotjaGi3g1v0487600, LotjaGi1g1v0766200, LotjaGi1g1v0781500, LotjaGi1g1v0578800, LotjaGi3g1v0274700, LotjaGi2g1v0228100, LotjaGi4g1v0338800, LotjaGi2g1v0341400, LotjaGi1g1v0315100, LotjaGi1g1v0544500, LotjaGi5g1v0019000, LotjaGi5g1v0202500, LotjaGi4g1v0107800, LotjaGi3g1v0150400, LotjaGi1g1v0098500, LotjaGi2g1v0000800, LotjaGi2g1v0177400, LotjaGi5g1v0178500, LotjaGi6g1v0097400, LotjaGi2g1v0005400, LotjaGi1g1v0667100, LotjaGi4g1v0006600, LotjaGi3g1v0347800, LotjaGi2g1v0430200, LotjaGi2g1v0143500, LotjaGi4g1v0074400, LotjaGi4g1v0346500, LotjaGi4g1v0068000, LotjaGi5g1v0226200, LotjaGi3g1v0464000, LotjaGi6g1v0005900, LotjaGi3g1v0468000, LotjaGi3g1v0280300, LotjaGi5g1v0323100, LotjaGi4g1v0193600-LC, LotjaGi6g1v0155700, LotjaGi6g1v0253000, LotjaGi6g1v0184900, LotjaGi4g1v0299200, LotjaGi4g1v0463700, LotjaGi4g1v0235000, LotjaGi4g1v0227700, LotjaGi4g1v0114900-LC, LotjaGi5g1v0339200, LotjaGi6g1v0081800, LotjaGi1g1v0054800, LotjaGi3g1v0223400, LotjaGi4g1v0010100, LotjaGi5g1v0085800, LotjaGi4g1v0402200, LotjaGi3g1v0178100, LotjaGi4g1v0400500, LotjaGi1g1v0453100, LotjaGi2g1v0326500, LotjaGi6g1v0010000, LotjaGi3g1v0413600, LotjaGi4g1v0399100, LotjaGi2g1v0176600, LotjaGi4g1v0348500, LotjaGi5g1v0298500, LotjaGi2g1v0081400, LotjaGi6g1v0271600, LotjaGi3g1v0393500, LotjaGi1g1v0261100, LotjaGi1g1v0152000, LotjaGi5g1v0314700, LotjaGi6g1v0012300-LC, LotjaGi2g1v0137900, LotjaGi2g1v0106500, LotjaGi1g1v0361600, LotjaGi4g1v0266600, LotjaGi4g1v0185900, LotjaGi3g1v0426100, LotjaGi3g1v0533100, LotjaGi3g1v0002600, LotjaGi6g1v0128400-LC, LotjaGi3g1v0241200, LotjaGi1g1v0783200-LC, LotjaGi3g1v0460400, LotjaGi2g1v0357000, LotjaGi1g1v0005100, LotjaGi4g1v0278500-LC, LotjaGi2g1v0369100, LotjaGi1g1v0191800, LotjaGi3g1v0191800, LotjaGi2g1v0142600-LC, LotjaGi2g1v0199400, LotjaGi3g1v0222800, LotjaGi2g1v0129700, LotjaGi1g1v0799200, LotjaGi4g1v0191000, LotjaGi3g1v0083400, LotjaGi6g1v0098400, LotjaGi6g1v0233800, LotjaGi3g1v0324800, LotjaGi2g1v0310400, LotjaGi1g1v0471800, LotjaGi4g1v0005400, LotjaGi5g1v0111200-LC, LotjaGi1g1v0390100, LotjaGi1g1v0661600, LotjaGi3g1v0526400-LC, LotjaGi3g1v0107400, LotjaGi4g1v0261600, LotjaGi2g1v0278500, LotjaGi3g1v0494100, LotjaGi1g1v0515700, LotjaGi5g1v0047700, LotjaGi5g1v0167000, LotjaGi6g1v0217400, LotjaGi5g1v0285900, LotjaGi4g1v0039800, LotjaGi6g1v0327300, LotjaGi1g1v0688900, LotjaGi2g1v0431800, LotjaGi5g1v0034900, LotjaGi5g1v0355500, LotjaGi1g1v0691200, LotjaGi4g1v0236000, LotjaGi5g1v0344500, LotjaGi3g1v0457600-LC, LotjaGi4g1v0313800, LotjaGi4g1v0152900, LotjaGi5g1v0082200, LotjaGi4g1v0437000, LotjaGi3g1v0481200, LotjaGi1g1v0079200, LotjaGi2g1v0275000, LotjaGi2g1v0103900, LotjaGi6g1v0263000, LotjaGi6g1v0209300, LotjaGi2g1v0323700, LotjaGi1g1v0546000, LotjaGi4g1v0358100, LotjaGi5g1v0118700, LotjaGi4g1v0278300-LC, LotjaGi2g1v0018700, LotjaGi5g1v0242200, LotjaGi6g1v0049600, LotjaGi4g1v0199100, LotjaGi6g1v0197000, LotjaGi5g1v0174700, LotjaGi6g1v0016800, LotjaGi2g1v0291500, LotjaGi1g1v0692100, LotjaGi5g1v0297900, LotjaGi3g1v0414000, LotjaGi2g1v0401800, LotjaGi2g1v0424100, LotjaGi4g1v0246100, LotjaGi6g1v0045500, LotjaGi3g1v0177500, LotjaGi4g1v0406700, LotjaGi6g1v0181400, LotjaGi2g1v0308500, LotjaGi1g1v0636100, LotjaGi3g1v0147700-LC, LotjaGi3g1v0300200, LotjaGi6g1v0138400, LotjaGi1g1v0545900, LotjaGi1g1v0567100, LotjaGi1g1v0758000-LC, LotjaGi6g1v0294700, LotjaGi4g1v0430000, LotjaGi3g1v0081700, LotjaGi6g1v0050600, LotjaGi6g1v0228700, LotjaGi6g1v0165600, LotjaGi5g1v0345000, LotjaGi4g1v0141700, LotjaGi3g1v0074600, LotjaGi3g1v0055500, LotjaGi5g1v0301600-LC, LotjaGi5g1v0168500, LotjaGi3g1v0451700, LotjaGi1g1v0094700, LotjaGi1g1v0759800, LotjaGi6g1v0166800, LotjaGi1g1v0504700, LotjaGi4g1v0045000, LotjaGi1g1v0776200, LotjaGi5g1v0247100, LotjaGi6g1v0086100, LotjaGi5g1v0263900, LotjaGi3g1v0152600, LotjaGi3g1v0381800, LotjaGi3g1v0069500, LotjaGi1g1v0525500, LotjaGi1g1v0626900, LotjaGi3g1v0208100, LotjaGi1g1v0307300, LotjaGi5g1v0224700, LotjaGi6g1v0107500, LotjaGi1g1v0679300, LotjaGi2g1v0121500, LotjaGi4g1v0091000, LotjaGi2g1v0098800, LotjaGi3g1v0433100, LotjaGi4g1v0096200, LotjaGi2g1v0093200, LotjaGi4g1v0194400, LotjaGi6g1v0065000-LC, LotjaGi1g1v0081100-LC, LotjaGi3g1v0034500, LotjaGi3g1v0078750, LotjaGi3g1v0041900, LotjaGi4g1v0390600, LotjaGi1g1v0768500-LC, LotjaGi4g1v0250800, LotjaGi5g1v0036100, LotjaGi3g1v0451900, LotjaGi1g1v0216700, LotjaGi1g1v0261000, LotjaGi5g1v0028600, LotjaGi2g1v0126400, LotjaGi6g1v0310100, LotjaGi2g1v0400400, LotjaGi2g1v0193900, LotjaGi4g1v0461300, LotjaGi3g1v0387900, LotjaGi4g1v0332500, LotjaGi2g1v0019100, LotjaGi4g1v0036300, LotjaGi1g1v0736100, LotjaGi2g1v0245100, LotjaGi6g1v0266700, LotjaGi6g1v0008100, LotjaGi5g1v0222800, LotjaGi4g1v0231900, LotjaGi1g1v0744000, LotjaGi4g1v0019600, LotjaGi6g1v0304600, LotjaGi1g1v0071200, LotjaGi1g1v0473700, LotjaGi6g1v0086500, LotjaGi4g1v0330300, LotjaGi2g1v0309500, LotjaGi1g1v0636000, LotjaGi1g1v0271500, LotjaGi4g1v0299700-LC, LotjaGi1g1v0566000, LotjaGi4g1v0061600, LotjaGi4g1v0424500, LotjaGi5g1v0352800-LC, LotjaGi6g1v0070200, LotjaGi1g1v0673700, LotjaGi4g1v0253000, LotjaGi2g1v0168900, LotjaGi2g1v0362400, LotjaGi1g1v0684400-LC, LotjaGi5g1v0324400, LotjaGi3g1v0035700, LotjaGi3g1v0361600, LotjaGi3g1v0231900, LotjaGi2g1v0176900, LotjaGi2g1v0277100, LotjaGi1g1v0709700, LotjaGi1g1v0682100, LotjaGi1g1v0720300, LotjaGi6g1v0001700, LotjaGi2g1v0272700, LotjaGi1g1v0624800, LotjaGi5g1v0010700, LotjaGi6g1v0177900, LotjaGi6g1v0353500, LotjaGi3g1v0442400, LotjaGi3g1v0511600, LotjaGi4g1v0076100, LotjaGi6g1v0095700, LotjaGi2g1v0445600, LotjaGi3g1v0005000, LotjaGi2g1v0251400, LotjaGi1g1v0274100, LotjaGi6g1v0183300, LotjaGi3g1v0446100, LotjaGi3g1v0448900, LotjaGi3g1v0249200, LotjaGi3g1v0183200, LotjaGi4g1v0338600, LotjaGi3g1v0225600, LotjaGi2g1v0074700, LotjaGi3g1v0038500, LotjaGi2g1v0285700, LotjaGi1g1v0609600, LotjaGi2g1v0081200, LotjaGi2g1v0377700, LotjaGi3g1v0432500, LotjaGi2g1v0400000, LotjaGi5g1v0017600, LotjaGi2g1v0105800, LotjaGi6g1v0322500, LotjaGi4g1v0008300, LotjaGi1g1v0091300, LotjaGi1g1v0500100, LotjaGi4g1v0165100, LotjaGi6g1v0035000, LotjaGi3g1v0404000-LC, LotjaGi1g1v0240600-LC, LotjaGi3g1v0551400, LotjaGi4g1v0130900, LotjaGi6g1v0119900, LotjaGi4g1v0103300-LC, LotjaGi1g1v0562800, LotjaGi6g1v0236600, LotjaGi5g1v0236500, LotjaGi6g1v0092000, LotjaGi4g1v0395300, LotjaGi6g1v0334000”\n\n\n\nDEG_table &lt;- FindMarkers(seurat.clustered, \n                             assay='integrated',\n                             ident.1 = \"R7A\",\n                             ident.2 = \"Control\", \n                             group.by = \"Condition\",\n                             subset.ident=\"Cortex\",\n                             min.diff.pct = 0.3,\n                             verbose = TRUE, \n                             features = seurat.clustered@assays$integrated@var.features,\n                             test.use = \"wilcox\") %&gt;%\n                             filter(p_val_adj &lt;= 0.001 & abs(avg_log2FC)&gt;1) %&gt;%\n                             select(-p_val)\n\n\nDefaultAssay(seurat.clustered) &lt;- \"integrated\" #return to the integrated data\nDEG &lt;- data.frame()\ncluster.names &lt;- unique(Idents(seurat.clustered))\n\nfor(CLUSTER in cluster.names){\n    DEG_table &lt;- FindMarkers(seurat.clustered,\n                             assay='integrated',\n                             ident.1 = \"R7A\",\n                             ident.2 = \"Control\", \n                             group.by = \"Condition\",\n                             subset.ident=CLUSTER,\n                             verbose = TRUE, \n                             min.diff.pct = 0.3,\n                             features = seurat.clustered@assays$integrated@var.features,\n                             test.use = \"wilcox\") %&gt;%\n                             filter(p_val_adj &lt;= 0.001 & abs(avg_log2FC)&gt;1) %&gt;%\n                             select(-p_val)\n    if(dim(DEG_table)[1]&gt;0){\n        DEG_table$'cluster' &lt;- CLUSTER\n        DEG &lt;- rbind(DEG, DEG_table)}\n    else{\n        message(paste0(\"---&gt; Warning: No DE genes in cluster \", CLUSTER), appendLF=FALSE)}\n    message(paste0(\"Done with cluster \",CLUSTER), appendLF=FALSE)\n    }\n\nDEG &lt;- as.data.frame(DEG)\nDEG$gene &lt;- rownames(DEG)\n\nDone with cluster Cortex\nDone with cluster Trichoblasts\nDone with cluster Root tip\nDone with cluster Meristem\nDone with cluster Phloem\nDone with cluster Pericycle\nDone with cluster Stele\nDone with cluster Atrichoblasts\nDone with cluster Xylem\nDone with cluster Endodermis\nDone with cluster Quiescent center\n\n\nThe table looks like this. Columns represent:\n\naverage logfoldchange between R7A and Control\npercentage of cells in R7A expressing the gene\npercentage of cells in Control expressing the gene\nadjusted p-value\ncluster\ngene\n\nThere are some genes in the table\n\ndim(DEG)[1]\n\n712\n\n\nWe now integrate GO terms using a table of predefined GO terms. The function doing that is addGOterms:\n\ngo_table &lt;- read.table(\"../Data/LJ_GO_terms.gaf\", skip=6, sep='\\t', fill=TRUE, quote = \"\\\"\")\n\n\nDEG &lt;- addGOterms(DEG, go_table, n.cores = 16)\n\nSo we can see which GO terms are relevant in each cluster for the infected samples against the control:\n\nDEG %&gt;% filter(cluster==\"Cortex\" & GO!=\"Undefined\")\n\n\nA data.frame: 3 × 7\n\n\n\navg_log2FC\npct.1\npct.2\np_val_adj\ncluster\ngene\nGO\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n\n\n\n\nLotjaGi2g1v0246800\n3.061302\n0.414\n0.072\n1.208504e-294\nCortex\nLotjaGi2g1v0246800\nL-threonine 3-dehydrogenase; TAIR: AT1G23740.1 Oxidoreductase, zinc-binding dehydrogenase family protein; Swiss-Prot: sp\n\n\nLotjaGi1g1v0066900\n1.438645\n0.403\n0.072\n5.606684e-140\nCortex\nLotjaGi1g1v0066900\n1-aminocyclopropane-1-carboxylate oxidase; TAIR: AT1G05010.1 ethylene-forming enzyme; Swiss-Prot: sp\n\n\nLotjaGi1g1v0154100\n4.261879\n0.452\n0.119\n8.705013e-128\nCortex\nLotjaGi1g1v0154100\nFlavonol synthase; TAIR: AT5G08640.1 flavonol synthase 1; Swiss-Prot: sp\n\n\n\n\n\nFinally, we do not expect to find the RINRK1 gene as differentially expressed, because its expression is on average too low.\n\nDEG %&gt;% filter(gene==RINRK1.id)\n\n\nA data.frame: 0 × 7\n\n\navg_log2FC\npct.1\npct.2\np_val_adj\ncluster\ngene\nGO\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n\n\n\n\n\n\n\nWe can save the table for future use. Such a table can be downloaded and open in any table processor (such as Excel).\n\nwrite.csv(DEG_table, \"DEG_table.csv\")"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#sec-networks",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#sec-networks",
    "title": "Single Cell Analysis Tutorial",
    "section": "4.2 Coexpression analysis",
    "text": "4.2 Coexpression analysis\nWe use the package hdWGCNA to detect groups of cells expressed simultaneously, and we find which modules are differentially expressed in specific clusters. We look at the GO terms to gain biological insight in the data.\n\n\n\n\n\n\nNote\n\n\n\nBefore running hdWGCNA, we first have to set up the Seurat object. Most of the information computed by hdWGCNA will be stored in the Seurat object’s @misc slot.\n\n\nHere we will set up the Seurat object using the SetupForWGCNA function, specifying the name of the hdWGNCA experiment. This function also selects the genes that will be used for WGCNA. The user can select genes using three different approaches using the posse gene_select parameter:\n\nvariable: use the genes stored in the Seurat object’s VariableFeatures.\nfraction: use genes that are expressed in a certain fraction of cells for in the whole dataset or in each group of cells, specified by group.by.\ncustom: use genes that are specified in a custom list.\n\nIn this example, we will select genes that are expressed in at least 5% of cells in this dataset, and we will name our hdWGCNA experiment “tutorial”.\n\nseurat.clustered &lt;- LoadH5Seurat(\"seurat.clustered.h5Seurat\", verbose=FALSE)\n\nValidating h5Seurat file\n\nWarning message:\n“Adding a command log without an assay associated with it”\n\n\n\nseurat.clustered &lt;- SetupForWGCNA(\n  seurat.clustered,\n  gene_select = \"variable\",\n  fraction = 0.05, # fraction of cells that a gene needs to be expressed in order to be included\n  wgcna_name = \"tutorial\" # the name of the hdWGCNA experiment\n)\n\n\n4.2.1 Construct metacells\nAfter we have set up our Seurat object, the first step in running the hdWGCNA pipeline is to construct metacells from the single-cell dataset. Briefly, metacells are aggregates of small groups of similar cells originating from the same biological sample of origin.\n {#fig-hdwgcna, width=800}\n\n\n\n\n\n\nSomething more about hdWGCNA\n\n\n\n\n\nThe k-Nearest Neighbors (KNN) algorithm is used to identify groups of similar cells to aggregate, and then the average or summed expression of these cells is computed, thus yielding a metacell gene expression matrix (as if you had many bulk samples). The sparsity of the metacell expression matrix is considerably reduced when compared to the original expression matrix, and therefore it is preferable to use. We were originally motivated to use metacells in place of the original single cells because correlation network approaches such as WGCNA are sensitive to data sparsity.\nhdWGCNA includes a function MetacellsByGroups to construct metacell expression matrices given a single-cell dataset. This function constructs a new Seurat object for the metacell dataset which is stored internally in the hdWGCNA experiment. The group.by parameter determines which groups metacells will be constructed in. We only want to construct metacells from cells that came from the same biological sample of origin, so it is critical to pass that information to hdWGCNA via the group.by parameter. Additionally, we usually construct metacells for each cell type separately. Thus, in this example, we are grouping by Sample and cell type to achieve the desired result.\nThe number of cells to be aggregated k should be tuned based on the size of the input dataset, in general a lower number for k can be used for small datasets. We generally use k values between 20 and 75. The dataset used for this tutorial has 21,369 cells, and here we use k=30. The amount of allowable overlap between metacells can be tuned using the max_shared argument. There should be a range of k values that are suitable for reducing the sparsity while retaining cellular heterogeneity for a given dataset, rather than a single optimal value.\nNote: the authors of hdWGCNA have found that the metacell aggregation approach does not yield good results for extremely underrepresented cell types. For example, in this dataset, the Meristem and Xylem are the least represented, and will be excluded them from this analysis. MetacellsByGroups has a parameter min_cells to exclude groups that are smaller than a specified number of cells. Errors are likely to arise if the selected value for min_cells is too low.\n\n\n\nHere we construct metacells and normalize the resulting expression matrix using the following code (read the additional text in the box above to understand the parameters). Note how the clusters Xylem and Quiescent center are removed, simply because they contain too few cells and cannot be used. So from now on we do not consider them for the coexpression analysis. Note that we use the scaled integrated data matrix (assay integrated and slot scale.data), so that we take advantage of the integration procedure we have been running before to unbias the data from technical features.\n\n# construct metacells  in each group\nseurat.clustered &lt;- MetacellsByGroups(\n  seurat_obj = seurat.clustered,\n  group.by = c(\"predicted.id\", \"Condition\"), # specify metadata to split by cluster and condition\n  reduction = 'pca', # select the dimensionality reduction to perform KNN on\n  k = 30, # nearest-neighbors parameter\n  max_shared = 10, # maximum number of shared cells between two metacells\n  ident.group = 'predicted.id', # set the Idents of the metacell seurat object\n  assay = \"integrated\",\n  slot = \"scale.data\",\n  min_cells = 100,\n  wgcna_name = \"tutorial\",\n  verbose=TRUE\n)\n\nWarning message in MetacellsByGroups(seurat_obj = seurat.clustered, group.by = c(\"predicted.id\", :\n“Removing the following groups that did not meet min_cells: Quiescent center#Control, Quiescent center#R7A, Xylem#Control, Xylem#R7A”\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.64052287581699\nMedian shared cells bin-bin: 0\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.26674432149097\nMedian shared cells bin-bin: 1\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 0.346860782529572\nMedian shared cells bin-bin: 0\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 0.888643725646683\nMedian shared cells bin-bin: 1\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.5741935483871\nMedian shared cells bin-bin: 0\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.83823529411765\nMedian shared cells bin-bin: 1\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 3.31111111111111\nMedian shared cells bin-bin: 2\n\nWarning message in (function (seurat_obj, name = \"agg\", ident.group = \"seurat_clusters\", :\n“On average, more than 10% of cells are shared between paired bins.”\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 6.7\nMedian shared cells bin-bin: 8\n\nWarning message in (function (seurat_obj, name = \"agg\", ident.group = \"seurat_clusters\", :\n“On average, more than 10% of cells are shared between paired bins.”\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 2.85789473684211\nMedian shared cells bin-bin: 1\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.70824524312896\nMedian shared cells bin-bin: 1\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 9\nMean shared cells bin-bin: 3\nMedian shared cells bin-bin: 1.5\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 4.97222222222222\nMedian shared cells bin-bin: 5\n\nWarning message in (function (seurat_obj, name = \"agg\", ident.group = \"seurat_clusters\", :\n“On average, more than 10% of cells are shared between paired bins.”\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 0.676916171024576\nMedian shared cells bin-bin: 0\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.53609831029186\nMedian shared cells bin-bin: 1\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.27272727272727\nMedian shared cells bin-bin: 0\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.43179880647911\nMedian shared cells bin-bin: 1\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.51052048726467\nMedian shared cells bin-bin: 0\n\nOverlap QC metrics:\nCells per bin: 30\nMaximum shared cells bin-bin: 10\nMean shared cells bin-bin: 1.55862775217614\nMedian shared cells bin-bin: 1\n\n\n\nThe metacell matrix always needs to be normalized, which is immediately done below\n\n#normalize metacell expression matrix:\nseurat.clustered &lt;- NormalizeMetacells(seurat.clustered)\n\nWarning message:\n“Cannot find a parent environment called Seurat”\n\n\nHere we specify the expression matrix that we will use for network analysis. It is natural to choose the integrated data matrix (which is chosen with the assay integrated and the matrix slot counts). We still need the data matrix after building the gene coexpression network when we want to evaluate the expression of each cell and gene in the original data.\n\nseurat.clustered &lt;- SetDatExpr(\n  seurat.clustered,\n  group_name = c('Pericycle','Cortex','Trichoblasts','Root tip',\n                 'Phloem','Stele','Endodermis','Atrichoblasts',\n                 'Meristem'), #all groups of interest in the data (we use all clusters)\n  group.by='predicted.id', # the metadata column containing the cell type info. This same column should have also been used in MetacellsByGroups\n  assay = 'integrated', # using integrated assay\n  slot = 'counts' # using count data\n)\n\n\n\n4.2.2 Select soft-power threshold\nNext we will select the soft power threshold. This is an extremely important step in the pipeline. hdWGCNA constructs a gene-gene correlation adjacency matrix to infer co-expression relationships between genes. The correlations are raised to a power to reduce the amount of noise present in the correlation matrix, thereby retaining the strong connections and removing the weak connections. Therefore, it is critical to determine a proper value for the soft power threshold.\nWe use the function TestSoftPowers to perform a parameter sweep for different soft power thresholds. This function helps us to guide our choice in a soft power threshold for constructing the co-expression network by inspecting the resulting network topology for different power values. The following code performs the parameter sweep and outputs a summary figure.\n\n# Test different soft powers:\nseurat.clustered &lt;- TestSoftPowers(powers = 1:50,\n  seurat.clustered,\n  networkType = 'signed'\n)\n\n# plot the results:\nplot_list &lt;- PlotSoftPowers(seurat.clustered)\n\n# assemble with patchwork\nwrap_plots(plot_list, ncol=2)\n\npickSoftThreshold: will use block size 2000.\n pickSoftThreshold: calculating connectivity for given powers...\n   ..working on genes 1 through 2000 of 2000\n   Power SFT.R.sq  slope truncated.R.sq  mean.k. median.k.  max.k.\n1      1   0.7040  5.810          0.864 1.19e+03  1.21e+03 1400.00\n2      2   0.3190  1.640          0.800 7.29e+02  7.42e+02 1020.00\n3      3   0.0118  0.208          0.806 4.59e+02  4.63e+02  762.00\n4      4   0.1290 -0.619          0.869 2.96e+02  2.93e+02  585.00\n5      5   0.3790 -1.050          0.929 1.95e+02  1.88e+02  459.00\n6      6   0.5690 -1.340          0.961 1.31e+02  1.22e+02  367.00\n7      7   0.6620 -1.500          0.965 9.02e+01  8.02e+01  298.00\n8      8   0.7310 -1.630          0.977 6.31e+01  5.31e+01  246.00\n9      9   0.7900 -1.710          0.979 4.50e+01  3.54e+01  205.00\n10    10   0.8280 -1.760          0.983 3.26e+01  2.37e+01  173.00\n11    11   0.8590 -1.800          0.988 2.40e+01  1.60e+01  147.00\n12    12   0.8690 -1.840          0.986 1.79e+01  1.08e+01  127.00\n13    13   0.8730 -1.880          0.984 1.36e+01  7.50e+00  110.00\n14    14   0.8930 -1.860          0.988 1.04e+01  5.15e+00   95.70\n15    15   0.9030 -1.850          0.986 8.08e+00  3.56e+00   84.00\n16    16   0.9120 -1.850          0.994 6.34e+00  2.48e+00   74.20\n17    17   0.9150 -1.840          0.989 5.03e+00  1.72e+00   65.80\n18    18   0.9200 -1.810          0.992 4.02e+00  1.21e+00   58.70\n19    19   0.9090 -1.800          0.973 3.25e+00  8.88e-01   52.50\n20    20   0.8780 -1.840          0.940 2.64e+00  6.34e-01   47.20\n21    21   0.9180 -1.790          0.987 2.16e+00  4.64e-01   42.60\n22    22   0.9280 -1.770          0.994 1.78e+00  3.37e-01   38.50\n23    23   0.9380 -1.750          0.995 1.48e+00  2.50e-01   35.00\n24    24   0.9390 -1.750          0.992 1.24e+00  1.83e-01   31.90\n25    25   0.9410 -1.720          0.993 1.04e+00  1.33e-01   29.10\n26    26   0.9440 -1.690          0.990 8.78e-01  9.76e-02   26.60\n27    27   0.9200 -1.690          0.955 7.45e-01  7.20e-02   24.40\n28    28   0.9280 -1.680          0.957 6.36e-01  5.31e-02   22.50\n29    29   0.9340 -1.670          0.956 5.44e-01  4.00e-02   20.70\n30    30   0.9320 -1.660          0.951 4.68e-01  2.99e-02   19.10\n31    31   0.9540 -1.630          0.978 4.04e-01  2.24e-02   17.70\n32    32   0.9550 -1.620          0.976 3.50e-01  1.66e-02   16.40\n33    33   0.9550 -1.620          0.976 3.04e-01  1.26e-02   15.30\n34    34   0.9550 -1.610          0.970 2.66e-01  9.86e-03   14.20\n35    35   0.9630 -1.590          0.980 2.33e-01  7.41e-03   13.20\n36    36   0.9510 -1.590          0.961 2.04e-01  5.64e-03   12.40\n37    37   0.9520 -1.570          0.958 1.80e-01  4.27e-03   11.60\n38    38   0.9580 -1.560          0.960 1.59e-01  3.22e-03   10.80\n39    39   0.3870 -2.160          0.317 1.41e-01  2.50e-03   10.20\n40    40   0.3890 -2.150          0.317 1.25e-01  1.93e-03    9.54\n41    41   0.3900 -2.120          0.323 1.11e-01  1.49e-03    8.97\n42    42   0.3920 -2.110          0.323 9.94e-02  1.15e-03    8.44\n43    43   0.3920 -2.090          0.323 8.90e-02  8.93e-04    7.96\n44    44   0.3910 -2.050          0.315 7.99e-02  6.95e-04    7.51\n45    45   0.3940 -2.030          0.317 7.18e-02  5.47e-04    7.10\n46    46   0.3950 -2.020          0.319 6.47e-02  4.28e-04    6.71\n47    47   0.3960 -2.010          0.318 5.85e-02  3.33e-04    6.36\n48    48   0.3990 -1.990          0.319 5.29e-02  2.55e-04    6.02\n49    49   0.4000 -1.980          0.318 4.80e-02  1.97e-04    5.72\n50    50   0.4000 -1.960          0.315 4.36e-02  1.56e-04    5.43\n  Power  SFT.R.sq      slope truncated.R.sq   mean.k. median.k.    max.k.\n1     1 0.7044481  5.8105577      0.8637387 1189.8481 1207.0679 1400.9927\n2     2 0.3189464  1.6432278      0.7995616  728.9757  741.5904 1017.7691\n3     3 0.0118177  0.2081181      0.8058857  458.5484  462.9321  761.7961\n4     4 0.1291123 -0.6185606      0.8688956  295.5520  293.2026  584.7981\n5     5 0.3787799 -1.0460651      0.9288564  194.8670  188.1986  458.7552\n6     6 0.5691444 -1.3404624      0.9608961  131.2447  122.2770  366.6863\n\n\nWarning message:\n“executing %dopar% sequentially: no parallel backend registered”\n\n\n\n\n\nFigure 28: Parameter sweep to choose the soft power threshold\n\n\n\n\nThe general guidance for hdWGCNA is to pick the lowest soft power threshold that has Model Fit greater than or equal to 0.8. We will do it automatically, so you do not need to do it manually following the illustration fo Figure 28."
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#construction-of-co-expression-network",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#construction-of-co-expression-network",
    "title": "Single Cell Analysis Tutorial",
    "section": "4.3 Construction of co-expression network",
    "text": "4.3 Construction of co-expression network\nWe now have everything that we need to construct our co-expression network. Here we use the hdWGCNA function ConstructNetwork. This function has quite a few parameters to play with if you are an advanced user (read this manual and the function ConstructNetwork is based on here), but we use default parameters that work well with many single-cell datasets.\nThe following code selects the power threshold from the values plotted in Figure 28 and constructs the co-expression network.\n\n# automatic choice of soft power value\nsoftPowerValue &lt;- which(seurat.clustered@misc$tutorial$wgcna_powerTable$SFT.R.sq &gt; .8)[1]\nmessage(paste0(\"Chosen Soft Power Value: \",softPowerValue))\n\n#multithreading for faster calculations\nenableWGCNAThreads(nThreads = 8)\n\n# construct co-expression network\nseurat.clustered &lt;- ConstructNetwork(na.rm=TRUE,\n  seurat.clustered,\n  soft_power=softPowerValue,                                   \n  setDatExpr=FALSE,\n  tom_name = 'Network', # name of the topoligical overlap matrix written to disk\n  overwrite_tom = TRUE,\n  randomSeed = 123\n)\n\nChosen Soft Power Value: 10\n\nWarning message in ConstructNetwork(na.rm = TRUE, seurat.clustered, soft_power = softPowerValue, :\n“Overwriting TOM TOM/Network_TOM.rda”\n\n\nAllowing parallel execution with up to 8 working processes.\n Calculating consensus modules and module eigengenes block-wise from all genes\n Calculating topological overlaps block-wise from all genes\n   Flagging genes and samples with too many missing values...\n    ..step 1\n    TOM calculation: adjacency..\n    ..will use 8 parallel threads.\n     Fraction of slow calculations: 0.000000\n    ..connectivity..\n    ..matrix multiplication (system BLAS)..\n    ..normalization..\n    ..done.\n ..Working on block 1 .\n ..Working on block 1 .\n ..merging consensus modules that are too close..\n\n\nWe can plot the network dendrogram in Figure 29. Each leaf on the dendrogram represents a single gene, and the color at the bottom indicates the co-expression module assignment. Clusters with similar brancing heights contain genes that are more similar to each other in terms of expression patterns when compared to genes in clusters with higher variation in merging heights.\n\n\n\n\n\n\nNote\n\n\n\nthe “gray” module consists of genes that were not grouped into any co-expression module. The gray module is to be ignored for all downstream analysis and interpretation.**\n\n\n\nPlotDendrogram(seurat.clustered, main='Phloem hdWGCNA Dendrogram')\n\n\n\n\nFigure 29: Dendrogram of the genes coexpression network. Leaves at the bottom are genes, and the colours represent a module of coexpression for the corresponding genes. Gray areas are for genes not included in any module.\n\n\n\n\n\n4.3.1 Module Eigengenes (MEs)\nWe calculate harmonized module eigengenes. This is a way of doing PCA of the expression matrix of metacells including the genes of one coexpression module at a time. Thus we have a PCA of the data for each module. The first principal component of each PCA is called module eigengene: it is enough to distinguish one module from all the others and characterize the expression pattern of the module (Langfelder and Horvath (2007))!\nDimensionality reduction techniques are a very hot topic in single-cell genomics (Xiang et al. (2021)). It is well known that technical artifacts can muddy the analysis of single-cell datasets, and over the years there have been many methods that aim to reduce the effects of these artifacts. Therefore it stands to reason that MEs would be subject to these technical artifacts as well, and hdWGCNA seeks to alleviate these effects by using the integration software Harmony (Korsunsky et al. (2019)).\nThe following code performs the module eigengene computation harmonizing by the Sample of origin using the group.by.vars parameter. We need to run ScaleData to avoid errors from the harmony software.\n\n# need to run ScaleData first or else harmony throws an error:\nseurat.clustered &lt;- ScaleData(seurat.clustered, \n                              features=VariableFeatures(seurat.clustered), \n                              verbose = FALSE)\n\nWe still want to use the integrated data matrix to calculate the modules eigengenes, so we assign the scaled matrix to the counts slot, which is where hdWGCNA looks by default for computing module eigengenes.\n\nseurat.clustered@assays$integrated@counts &lt;- seurat.clustered@assays$integrated@scale.data\n\n\n# compute all MEs in the full single-cell dataset\nseurat.clustered &lt;- ModuleEigengenes( \n seurat.clustered,\n group.by.vars=\"orig.ident\",\n verbose = FALSE\n)\n\n[1] \"yellow\"\n[1] \"turquoise\"\n[1] \"tan\"\n[1] \"brown\"\n[1] \"red\"\n[1] \"lightcyan\"\n[1] \"cyan\"\n[1] \"pink\"\n[1] \"salmon\"\n[1] \"grey\"\n[1] \"purple\"\n[1] \"greenyellow\"\n[1] \"green\"\n[1] \"midnightblue\"\n[1] \"blue\"\n[1] \"black\"\n[1] \"magenta\"\n\n\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcayellow to pcayellow_”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcaturquoise to pcaturquoise_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘xlofa_’ instead”\nCentering and scaling data matrix\n\nWarning message in irlba(A = t(x = object), nv = npcs, ...):\n“You're computing too large a percentage of total singular values, use a standard svd instead.”\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcatan to pcatan_”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcabrown to pcabrown_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘ujakm_’ instead”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcared to pcared_”\nCentering and scaling data matrix\n\nWarning message in irlba(A = t(x = object), nv = npcs, ...):\n“You're computing too large a percentage of total singular values, use a standard svd instead.”\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcalightcyan to pcalightcyan_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘uyrtn_’ instead”\nCentering and scaling data matrix\n\nWarning message in irlba(A = t(x = object), nv = npcs, ...):\n“You're computing too large a percentage of total singular values, use a standard svd instead.”\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcacyan to pcacyan_”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcapink to pcapink_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘sakpn_’ instead”\nCentering and scaling data matrix\n\nWarning message in irlba(A = t(x = object), nv = npcs, ...):\n“You're computing too large a percentage of total singular values, use a standard svd instead.”\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcasalmon to pcasalmon_”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcagrey to pcagrey_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘esfhp_’ instead”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcapurple to pcapurple_”\nCentering and scaling data matrix\n\nWarning message in irlba(A = t(x = object), nv = npcs, ...):\n“You're computing too large a percentage of total singular values, use a standard svd instead.”\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcagreenyellow to pcagreenyellow_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘wajvi_’ instead”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcagreen to pcagreen_”\nCentering and scaling data matrix\n\nWarning message in irlba(A = t(x = object), nv = npcs, ...):\n“You're computing too large a percentage of total singular values, use a standard svd instead.”\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcamidnightblue to pcamidnightblue_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘rtnba_’ instead”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcablue to pcablue_”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcablack to pcablack_”\nWarning message:\n“Key ‘harmony_’ taken, using ‘logay_’ instead”\nCentering and scaling data matrix\n\nWarning message:\n“Keys should be one or more alphanumeric characters followed by an underscore, setting key from pcamagenta to pcamagenta_”\n\n\n\n\n4.3.2 Compute module connectivity\nIn co-expression network analysis, we often want to focus on the hub genes, those which are highly connected within each module. Therefore we wish to determine the eigengene-based connectivity, also known as kME, of each gene. The ModuleConnectivity function computes the kMEs in the single-cell dataset (rather than the metacell dataset). This function essentially computes pairwise correlations between genes and module eigengenes. kME can be computed for all cells in the dataset, but it is recommended computing kMEs in the cell type(s) or group(s) previously used to run ConstructNetwork.\n\n# compute eigengene-based connectivity (kME):\nseurat.clustered &lt;- ModuleConnectivity(\n  seurat.clustered,\n  group.by = 'predicted.id', \n  group_name = c('Pericycle','Cortex','Trichoblasts','Root tip',\n                 'Phloem','Stele','Endodermis','Atrichoblasts',\n                 'Meristem'),\n)\n\nFor convenience, we re-name the hdWGCNA modules to indicate such that they are not called cluster##, but Lotus-Mod## instead, which is a more meaningful name.\n\n# rename the modules\nseurat.clustered &lt;- ResetModuleNames(\n  seurat.clustered,\n  new_name = \"Lotus-Mod\"\n)\n\nWe can visualize the genes in each module ranked by kME using the PlotKMEs function. Each plot shows the kME-score (which is at most 1) for a module. On the left side of the y axis you see the kME scores (how much a gene is well-correlated with others in the module). On the right side of the y axis you have a bar showing how many genes have the corresponding kME score. The x axis should show the number of genes corresponding to the bar (but no number is shown by this plotting function). What is important to observe is that only few genes have high kME score in each module, and those are the ones you want to focus on. The top ten names are plotted for each module as well.\n\noptions(repr.plot.width=20, repr.plot.height=25)\np &lt;- capture.output({PlotKMEs(seurat.clustered, ncol=3, text_size = 4);})\n\n\n\n\nFigure 30: KMEs for each module, where the genes on the right of each plot gives the top genes based on the module’s KMEs. Each plot is a histogram which has been rotated, so that bars starting on the left side of the y axis represent the counts of how many genes have the connectivity written on the right side of the y axis. The number of counts should be written on the x axis, but is not plotted by the function.\n\n\n\n\n\n\n4.3.3 Getting the module assignment table\nThe plots of Figure 30 are a bit hard to read, though fancy to plot. hdWGCNA allows for easy access of the module assignment table using the GetModules function. This table consists of three columns: gene_name stores the gene’s symbol or ID, module stores the gene’s module assignment, and color stores a color mapping for each module (which is used in plotting steps). If ModuleConnectivity has been used on this hdWGCNA experiment, as it is our case, this table has additional columns with the connectivities plotted in Figure 30\n\n# get the module assignment table:\nmodules &lt;- GetModules(seurat.clustered)\n\n# show the first 6 columns:\nhead(modules[,1:6])\n\n\nA data.frame: 6 × 6\n\n\n\ngene_name\nmodule\ncolor\nkME_Lotus-Mod1\nkME_Lotus-Mod2\nkME_Lotus-Mod3\n\n\n\n&lt;chr&gt;\n&lt;fct&gt;\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nLotjaGi3g1v0222100\nLotjaGi3g1v0222100\nLotus-Mod1\nyellow\n0.66927700\n-0.16607049\n-0.20407421\n\n\nLotjaGi2g1v0360900\nLotjaGi2g1v0360900\nLotus-Mod2\nturquoise\n-0.14382340\n0.90236572\n-0.24851350\n\n\nLotjaGi3g1v0445300\nLotjaGi3g1v0445300\nLotus-Mod3\ntan\n-0.18127709\n-0.21469999\n0.86945694\n\n\nLotjaGi3g1v0506700\nLotjaGi3g1v0506700\nLotus-Mod2\nturquoise\n-0.13031149\n0.72715888\n-0.20028857\n\n\nLotjaGi2g1v0160200\nLotjaGi2g1v0160200\nLotus-Mod4\nbrown\n-0.12981105\n-0.02298910\n-0.08982969\n\n\nLotjaGi5g1v0119900\nLotjaGi5g1v0119900\nLotus-Mod5\nred\n0.02807917\n-0.09403294\n-0.17121588\n\n\n\n\n\nA table of the top N hub genes sorted by kME can be extracted using the GetHubGenes function. Here we choose the top 10 genes, but you can change the value if you want. The table contains all the top 10 genes for each module, the name of the module they come from and the kME score.\n\n# get hub genes\nhub_df &lt;- GetHubGenes(seurat.clustered, n_hubs = 10)\n# print the first lines of the table to see its structure\nhead( hub_df )\n\n\nA data.frame: 6 × 3\n\n\n\ngene_name\nmodule\nkME\n\n\n\n&lt;chr&gt;\n&lt;fct&gt;\n&lt;dbl&gt;\n\n\n\n\n1\nLotjaGi1g1v0160700\nLotus-Mod1\n0.8112420\n\n\n2\nLotjaGi6g1v0003600\nLotus-Mod1\n0.7821258\n\n\n3\nLotjaGi1g1v0783700-LC\nLotus-Mod1\n0.7813964\n\n\n4\nLotjaGi6g1v0273300-LC\nLotus-Mod1\n0.7544668\n\n\n5\nLotjaGi5g1v0047400\nLotus-Mod1\n0.7442475\n\n\n6\nLotjaGi5g1v0188800\nLotus-Mod1\n0.7403723\n\n\n\n\n\nAgain, we can assign GO terms to better check associated functions\n\ngo_table &lt;- read.table(\"../Data/LJ_GO_terms.gaf\", skip=6, sep='\\t', fill=TRUE, quote = \"\\\"\")\n\n\nhub_df &lt;- addGOterms(input_table = hub_df, \n                     go_table = go_table, \n                     gene_column = 'gene_name',\n                     n.cores = 16)\n\nNow it is easy to look at each module and relevant GO terms.\n\nhub_filtered &lt;- hub_df %&gt;% filter(module == \"Lotus-Mod3\")\n\n\nhub_filtered\n\n\nA data.frame: 10 × 4\n\n\ngene_name\nmodule\nkME\nGO\n\n\n&lt;chr&gt;\n&lt;fct&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n\n\n\n\nLotjaGi3g1v0445300\nLotus-Mod3\n0.8694569\nUndefined\n\n\nLotjaGi4g1v0275500\nLotus-Mod3\n0.8430255\nUndefined\n\n\nLotjaGi4g1v0208100\nLotus-Mod3\n0.7431116\nUndefined\n\n\nLotjaGi1g1v0594900\nLotus-Mod3\n0.7429926\nUndefined\n\n\nLotjaGi3g1v0505900\nLotus-Mod3\n0.7373019\nUndefined\n\n\nLotjaGi2g1v0406200\nLotus-Mod3\n0.7185567\nUndefined\n\n\nLotjaGi6g1v0151500\nLotus-Mod3\n0.7072212\nUndefined\n\n\nLotjaGi6g1v0028000-LC\nLotus-Mod3\n0.7023895\nUndefined\n\n\nLotjaGi1g1v0502700\nLotus-Mod3\n0.7008408\nUndefined\n\n\nLotjaGi2g1v0402200\nLotus-Mod3\n0.6794909\nUndefined\n\n\n\n\n\nWe save the table for later use\n\nwrite.csv(hub_df, \"top_genes_networks.csv\")\n\nWe can also plot the modules to see where they are most relevant on the UMAP plot. First we calculate the scores of each module and renames each module from Cluster## to Lotus-Mod##. The scores are the same for the markers plots for clustering, but calculated instead on the genes of each module.\n\nfeatures_list &lt;- list()\n\nfor(MOD in hub_df$module){\n    genes &lt;- hub_df %&gt;% filter(module == MOD)\n    genes_mod &lt;- genes$gene_name\n    features_list[[MOD]] &lt;- genes_mod\n    }\n\nseurat.clustered &lt;- AddModuleScore(\n  object = seurat.clustered,\n  features = features_list,\n  ctrl = 5,\n)\n\nseurat.clustered &lt;- renameScores(markers_list = features_list, seurat_data = seurat.clustered)\nplotScoresUMAP(markers_list = features_list, seurat_data = seurat.clustered)\n\nScores renamed FROM\n\n\n\n\nTO\n\n\n\n\n\n\nCluster1\nCluster2\nCluster3\nCluster4\nCluster5\nCluster6\nCluster7\nCluster8\nCluster9\nCluster10\nCluster11\nCluster12\nCluster13\nCluster14\nCluster15\nCluster16\nLotus-Mod1\nLotus-Mod2\nLotus-Mod3\nLotus-Mod4\nLotus-Mod5\nLotus-Mod6\nLotus-Mod7\nLotus-Mod8\nLotus-Mod9\nLotus-Mod10\nLotus-Mod11\nLotus-Mod12\nLotus-Mod13\nLotus-Mod14\nLotus-Mod15\nLotus-Mod16\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nPlots can be hard to see when they are small. You can plot any module singularly. For example Mod1. You simply need to choose one of the elements from feature_list (below we chose feature_list[1] for Lotus-Mod1)\n\n\n\nplotScoresUMAP(markers_list = features_list[1], seurat_data = seurat.clustered)\n\n\n\n\nWe save the seurat object and the network separately (because for some inscrutable error, hdWGCNA cannot load together with the Seurat object when it is needed again).\n\nSaveH5Seurat(seurat.clustered, 'seurat.network.h5Seurat', overwrite = TRUE, verbose=FALSE)\n\nWarning message:\n“Overwriting previous file seurat.network.h5Seurat”\nCreating h5Seurat file for version 3.1.5.9900\n\n\n\n\nsaveRDS(seurat.clustered@misc, \"network_lotus.RDS\")"
  },
  {
    "objectID": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#differential-module-expression-dme-analysis",
    "href": "Modules/Infected_Plant_Gene_Analysis/Notebook/notebook.source.html#differential-module-expression-dme-analysis",
    "title": "Single Cell Analysis Tutorial",
    "section": "4.4 Differential module Expression (DME) analysis",
    "text": "4.4 Differential module Expression (DME) analysis\nLastly, we can see which modules are most expressed in a specific cluster against the others, in a similar way to differential gene expression.\n\nseurat.network &lt;- LoadH5Seurat('seurat.network.h5Seurat', misc=FALSE, verbose=FALSE)\n\nValidating h5Seurat file\n\nWarning message:\n“Adding a command log without an assay associated with it”\n\n\n[1] \"Couldn't delete        144115188075857558\"\n\n\n\nseurat.network@misc &lt;- readRDS(\"network_lotus.RDS\")\n\nHere we discuss how to perform DME testing between two different groups. We use the hdWGCNA function FindDMEs, which is similar to the Seurat function FindMarkers. We use the Mann-Whitney U test, also known as the Wilcoxon test, to compare two groups, but other tests can be used at the user’s discretion with the test.use parameter.\nWe are interested in defining our two groups both by condition. We filter DMEs by p-value and fold-change, so to remove non-significant ones from the list.\n\nR7Agroup &lt;- seurat.network@meta.data %&gt;% subset(Condition == 'R7A') %&gt;% rownames\nWTgroup &lt;- seurat.network@meta.data %&gt;% subset(Condition == 'Control') %&gt;% rownames\n\n\nDMEs &lt;- FindDMEs(\n  seurat.network,\n  barcodes1 = R7Agroup,\n  barcodes2 = WTgroup,\n  test.use='wilcox',\n  wgcna_name='tutorial'\n) %&gt;% filter(p_val_adj &lt; 0.001 & abs(avg_log2FC)&gt;1) %&gt;% select(-p_val)\n\nThe resulting table below is very similar to the one for differential gene expression. Now the p-values and fold changes are referred to the differential module expression in the inoculated VS the control cells. We can see there are some differences and one could study those modules in depth by looking at the top genes and their GO terms.\n\nDMEs\n\n\nA data.frame: 3 × 5\n\n\n\navg_log2FC\npct.1\npct.2\np_val_adj\nmodule\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n\n\n\n\nLotus-Mod2\n-1.078807\n0.130\n0.239\n5.577347e-93\nLotus-Mod2\n\n\nLotus-Mod6\n1.120521\n0.276\n0.193\n8.258406e-49\nLotus-Mod6\n\n\nLotus-Mod15\n2.009786\n0.215\n0.165\n5.693663e-27\nLotus-Mod15\n\n\n\n\n\nGraphically, you can always produce a lollipop plot as in Figure 31, where the size of each circle is the p-value, and the x-axis is the log-fold change. A cross on a circle means the p-value is not significant. In our case we filtered out p-values that were too high, so we have only significant modules in the plot.\n\noptions(repr.plot.width=6, repr.plot.height=6)\n\nPlotDMEsLollipop(\n  seurat.network, \n  DMEs, \n  wgcna_name='tutorial', \n  pvalue = \"p_val_adj\",\n)\n\nLoading required package: ggforestplot\n\n\n\n[1] \"Please be aware comparison group/groups are not provided, which may casue an ERROR. PlotDMEsLollipop function will automatically assume all values are within the same group.\"\n\n\n\n\n\nFigure 31: Lollipop plot that shovs the average log-fold change of each module and the p-value (size of each circle). Crossed circles, when present, have a non-significant p-value\n\n\n\n\n\n4.4.1 One-versus-all DME analysis\nThis is another case of DME analysis, where each cluster is tested against the rest of the data to see which modules are differentially expressed and are specific of each cell type. We can test by cell type (predicted.id) or by condition (Condition), or by any other label a dataset might have and that is contained in the meta data.\n\nDMEs_all &lt;- FindAllDMEs(\n  seurat.network,\n  group.by = 'predicted.id',\n  wgcna_name = 'tutorial'\n) \n\n[1] \"Cortex\"\n[1] \"Trichoblasts\"\n[1] \"Root tip\"\n[1] \"Meristem\"\n[1] \"Phloem\"\n[1] \"Pericycle\"\n[1] \"Stele\"\n[1] \"Atrichoblasts\"\n[1] \"Xylem\"\n[1] \"Endodermis\"\n[1] \"Quiescent center\"\n\n\nThe table is usually big, but you can choose to filter by various parameters as below, and to look only at one cluster of interest\n\nDMEs_cortex &lt;- DMEs_all %&gt;% filter(p_val_adj &lt; .001 & abs(avg_log2FC)&gt;1 \n                                       & is.finite(avg_log2FC)\n                                       & group=='Cortex')\n\nThe DME analysis results in a lot of significant results for the cortex. The most significant modules for a cluster are the ones where pct.1 and pct.2 are very different, and at the same time have a large fold-change and a small p-value. The column group tells you in which cluster the module is differentially overexpressed (positive fold-change avg_log2FC) or underexpressed (negative fold-change).\n\nDMEs_cortex\n\n\nA data.frame: 14 × 7\n\n\n\np_val\navg_log2FC\npct.1\npct.2\np_val_adj\nmodule\ngroup\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n\n\n\n\nCortex.Lotus-Mod3\n0.000000e+00\n2.371340\n0.480\n0.152\n0.000000e+00\nLotus-Mod3\nCortex\n\n\nCortex.Lotus-Mod6\n0.000000e+00\n2.666149\n0.408\n0.125\n0.000000e+00\nLotus-Mod6\nCortex\n\n\nCortex.Lotus-Mod14\n0.000000e+00\n2.453980\n0.523\n0.225\n0.000000e+00\nLotus-Mod14\nCortex\n\n\nCortex.Lotus-Mod1\n0.000000e+00\n-4.708455\n0.061\n0.277\n0.000000e+00\nLotus-Mod1\nCortex\n\n\nCortex.Lotus-Mod7\n0.000000e+00\n-4.395113\n0.082\n0.370\n0.000000e+00\nLotus-Mod7\nCortex\n\n\nCortex.Lotus-Mod11\n0.000000e+00\n-4.699137\n0.034\n0.296\n0.000000e+00\nLotus-Mod11\nCortex\n\n\nCortex.Lotus-Mod8\n0.000000e+00\n-3.563797\n0.108\n0.368\n0.000000e+00\nLotus-Mod8\nCortex\n\n\nCortex.Lotus-Mod15\n0.000000e+00\n-2.962244\n0.071\n0.289\n0.000000e+00\nLotus-Mod15\nCortex\n\n\nCortex.Lotus-Mod2\n0.000000e+00\n-5.524643\n0.033\n0.273\n0.000000e+00\nLotus-Mod2\nCortex\n\n\nCortex.Lotus-Mod4\n1.859292e-188\n-3.855152\n0.070\n0.211\n2.974867e-187\nLotus-Mod4\nCortex\n\n\nCortex.Lotus-Mod13\n3.339974e-141\n-3.844141\n0.073\n0.194\n5.343958e-140\nLotus-Mod13\nCortex\n\n\nCortex.Lotus-Mod9\n2.981487e-99\n-2.893193\n0.147\n0.254\n4.770380e-98\nLotus-Mod9\nCortex\n\n\nCortex.Lotus-Mod10\n3.126878e-65\n-3.120111\n0.108\n0.188\n5.003005e-64\nLotus-Mod10\nCortex\n\n\nCortex.Lotus-Mod12\n1.669763e-07\n-1.290486\n0.185\n0.215\n2.671620e-06\nLotus-Mod12\nCortex\n\n\n\n\n\nYou can look at any other cluster. For example trichoblasts. Here you can see how module 4 pops up as being basically entirely expressed only in Trichoblasts.\n\nDMEs_tricho &lt;- DMEs_all %&gt;% filter(p_val_adj &lt; .001 & abs(avg_log2FC)&gt;1 \n                                       & is.finite(avg_log2FC)\n                                       & group=='Trichoblasts')\n\n\nDMEs_tricho\n\n\nA data.frame: 15 × 7\n\n\n\np_val\navg_log2FC\npct.1\npct.2\np_val_adj\nmodule\ngroup\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n\n\n\n\nTrichoblasts.Lotus-Mod4\n0.000000e+00\n6.750784\n0.996\n0.076\n0.000000e+00\nLotus-Mod4\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod16\n5.097196e-185\n-6.481375\n0.014\n0.371\n8.155514e-184\nLotus-Mod16\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod14\n3.025439e-146\n-4.349619\n0.069\n0.376\n4.840702e-145\nLotus-Mod14\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod8\n1.126480e-121\n-4.872991\n0.014\n0.279\n1.802368e-120\nLotus-Mod8\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod7\n6.713357e-119\n-6.178666\n0.012\n0.269\n1.074137e-117\nLotus-Mod7\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod6\n1.863436e-115\n-5.773750\n0.013\n0.266\n2.981498e-114\nLotus-Mod6\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod5\n2.017255e-92\n-3.586865\n0.072\n0.299\n3.227608e-91\nLotus-Mod5\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod1\n7.273801e-83\n-6.444630\n0.010\n0.201\n1.163808e-81\nLotus-Mod1\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod11\n3.116022e-75\n-5.254196\n0.018\n0.199\n4.985635e-74\nLotus-Mod11\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod3\n7.598832e-73\n-3.568617\n0.117\n0.306\n1.215813e-71\nLotus-Mod3\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod12\n8.732984e-73\n-3.106583\n0.033\n0.217\n1.397277e-71\nLotus-Mod12\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod15\n3.656164e-65\n-3.844803\n0.039\n0.210\n5.849862e-64\nLotus-Mod15\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod9\n5.426530e-44\n-3.051174\n0.081\n0.220\n8.682448e-43\nLotus-Mod9\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod10\n1.031038e-29\n-3.738713\n0.061\n0.162\n1.649662e-28\nLotus-Mod10\nTrichoblasts\n\n\nTrichoblasts.Lotus-Mod13\n4.773544e-17\n-2.852839\n0.075\n0.149\n7.637670e-16\nLotus-Mod13\nTrichoblasts\n\n\n\n\n\nFor better visualization, you can always use the lolliplot plots using the correct table as an argument, so that you can plot multiple instances for the various clusters. In Figure 32 we plot boyh for cortex and trichoblasts from the tables determined in the code above.\n\noptions(repr.plot.width=12, repr.plot.height=6)\n\n#lollipop with cortex table\np1 &lt;- PlotDMEsLollipop(\n  seurat.network, \n  DMEs_cortex, \n  wgcna_name='tutorial', \n  pvalue = \"p_val_adj\",\n)\n\n#lollipop with trichoblasts table\np2 &lt;- PlotDMEsLollipop(\n  seurat.network, \n  DMEs_tricho, \n  wgcna_name='tutorial', \n  pvalue = \"p_val_adj\",\n)\n\n#plot an add a title\np1 + ggtitle(\"DMEs of Cortex VS data\") + \np2 + ggtitle(\"DMEs of Trichoblasts VS data\")\n\n[1] \"Please be aware comparison group/groups are not provided, which may casue an ERROR. PlotDMEsLollipop function will automatically assume all values are within the same group.\"\n[1] \"Please be aware comparison group/groups are not provided, which may casue an ERROR. PlotDMEsLollipop function will automatically assume all values are within the same group.\"\n\n\n\n\n\nFigure 32: Lollipop plot that shovs the average log-fold change of each module and the p-value (size of each circle). Crossed circles, when present, have a non-significant p-value. Plotting lolliplot plots for various clusters can be useful to detect modules being simultaneously significant.\n\n\n\n\n\n\n\n\n\n\nWrapping Up\n\n\n\nThis is the end of the tutorial. We have not shown much biological conclusion from the analysis - this is something that comes out by studying for example the GO terms of the various genes and modules identified. The scope of the tutorial was mainly to give all the means to perform your own analysis, from which you can then gain biological insight.\nIf you are interested in more resources to learn single cell analysis, you can find them at some of our courses. We have other single-cell analysis tutorials including different tools at\n\nIntroduction to NGS data analysis (found in the Genomics Sandbox at this link - note that this is in the python language )\nIntroduction to scRNAseq analysis in R (found in the Transcriptomics Sandbox at this link )\n\nYou can also find a lot of material in the Seurat webpage. If you create a new notebook in this environment, you are likely to have all the packages needed to try the Seurat tutorials."
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "Advanced single cell analysis",
    "section": "",
    "text": "Attribution-ShareAlike 4.0 International\n=======================================================================\nCreative Commons Corporation (“Creative Commons”) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an “as-is” basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.\nUsing Creative Commons Public Licenses\nCreative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.\n Considerations for licensors: Our public licenses are\n intended for use by those authorized to give the public\n permission to use material in ways otherwise restricted by\n copyright and certain other rights. Our licenses are\n irrevocable. Licensors should read and understand the terms\n and conditions of the license they choose before applying it.\n Licensors should also secure all rights necessary before\n applying our licenses so that the public can reuse the\n material as expected. Licensors should clearly mark any\n material not subject to the license. This includes other CC-\n licensed material, or material used under an exception or\n limitation to copyright. More considerations for licensors:\nwiki.creativecommons.org/Considerations_for_licensors\n\n Considerations for the public: By using one of our public\n licenses, a licensor grants the public permission to use the\n licensed material under specified terms and conditions. If\n the licensor's permission is not necessary for any reason--for\n example, because of any applicable exception or limitation to\n copyright--then that use is not regulated by the license. Our\n licenses grant only permissions under copyright and certain\n other rights that a licensor has authority to grant. Use of\n the licensed material may still be restricted for other\n reasons, including because others have copyright or other\n rights in the material. A licensor may make special requests,\n such as asking that all changes be marked or described.\n Although not required by our licenses, you are encouraged to\n respect those requests where reasonable. More_considerations\n for the public:\nwiki.creativecommons.org/Considerations_for_licensees\n=======================================================================\nCreative Commons Attribution-ShareAlike 4.0 International Public License\nBy exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License (“Public License”). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.\nSection 1 – Definitions.\n\nAdapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.\nAdapter’s License means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.\nBY-SA Compatible License means a license listed at creativecommons.org/compatiblelicenses, approved by Creative Commons as essentially the equivalent of this Public License.\nCopyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.\nEffective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.\nExceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.\nLicense Elements means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike.\nLicensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License.\nLicensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.\nLicensor means the individual(s) or entity(ies) granting rights under this Public License.\nShare means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.\nSui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.\nYou means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.\n\nSection 2 – Scope.\n\nLicense grant.\n\nSubject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:\n\nreproduce and Share the Licensed Material, in whole or in part; and\nproduce, reproduce, and Share Adapted Material.\n\nExceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.\nTerm. The term of this Public License is specified in Section 6(a).\nMedia and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)\n\nnever produces Adapted Material.\n\nDownstream recipients.\n\nOffer from the Licensor – Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.\nAdditional offer from the Licensor – Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapter’s License You apply.\nNo downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.\n\nNo endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).\n\nOther rights.\n\nMoral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.\nPatent and trademark rights are not licensed under this Public License.\nTo the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.\n\n\nSection 3 – License Conditions.\nYour exercise of the Licensed Rights is expressly made subject to the following conditions.\n\nAttribution.\n\nIf You Share the Licensed Material (including in modified form), You must:\n\nretain the following if it is supplied by the Licensor with the Licensed Material:\n\nidentification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);\na copyright notice;\na notice that refers to this Public License;\na notice that refers to the disclaimer of warranties;\na URI or hyperlink to the Licensed Material to the extent reasonably practicable;\n\nindicate if You modified the Licensed Material and retain an indication of any previous modifications; and\nindicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.\n\nYou may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.\nIf requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.\n\nShareAlike.\nIn addition to the conditions in Section 3(a), if You Share Adapted Material You produce, the following conditions also apply.\n\nThe Adapter’s License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License.\nYou must include the text of, or the URI or hyperlink to, the Adapter’s License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material.\nYou may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter’s License You apply.\n\n\nSection 4 – Sui Generis Database Rights.\nWhere the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:\n\nfor the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database;\nif You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material,\nincluding for purposes of Section 3(b); and\nYou must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.\nSection 5 – Disclaimer of Warranties and Limitation of Liability.\n\nUNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS, IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.\nTO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES, COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.\nThe disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.\n\nSection 6 – Term and Termination.\n\nThis Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.\nWhere Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:\n\nautomatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or\nupon express reinstatement by the Licensor.\n\nFor the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.\nFor the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.\nSections 1, 5, 6, 7, and 8 survive termination of this Public License.\n\nSection 7 – Other Terms and Conditions.\n\nThe Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.\nAny arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.\n\nSection 8 – Interpretation.\n\nFor the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.\nTo the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.\nNo term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.\nNothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.\n\n=======================================================================\nCreative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the “Licensor.” The text of the Creative Commons public licenses is dedicated to the public domain under the CC0 Public Domain Dedication. Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark “Creative Commons” or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.\nCreative Commons may be contacted at creativecommons.org."
  }
]